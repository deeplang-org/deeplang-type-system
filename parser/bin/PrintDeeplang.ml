(* pretty-printer generated by the BNF converter *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 4

let indent (i: int) : string = "\n" ^ String.make i ' '

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let whitespace = match last with
        None -> ""
      | Some '{' -> indent i
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent i)
      | Some ';' -> indent i
      | (Some '[') |  (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
            "," | ")" | "]" -> ""
           | _ -> if String.trim s = "" then "" else " ") in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtIF _ (AbsDeeplang.IF (_,i)) : doc = render i


let rec prtELSE _ (AbsDeeplang.ELSE (_,i)) : doc = render i


let rec prtWHILE _ (AbsDeeplang.WHILE (_,i)) : doc = render i


let rec prtFOR _ (AbsDeeplang.FOR (_,i)) : doc = render i


let rec prtIN _ (AbsDeeplang.IN (_,i)) : doc = render i


let rec prtLET _ (AbsDeeplang.LET (_,i)) : doc = render i


let rec prtFUN _ (AbsDeeplang.FUN (_,i)) : doc = render i


let rec prtMUT _ (AbsDeeplang.MUT (_,i)) : doc = render i


let rec prtINTERFACE _ (AbsDeeplang.INTERFACE (_,i)) : doc = render i


let rec prtIMPL _ (AbsDeeplang.IMPL (_,i)) : doc = render i


let rec prtAS _ (AbsDeeplang.AS (_,i)) : doc = render i


let rec prtMATCH _ (AbsDeeplang.MATCH (_,i)) : doc = render i


let rec prtTYPE _ (AbsDeeplang.TYPE (_,i)) : doc = render i


let rec prtEXTENDS _ (AbsDeeplang.EXTENDS (_,i)) : doc = render i


let rec prtTypeId _ (AbsDeeplang.TypeId (_,i)) : doc = render i


let rec prtBaseType _ (AbsDeeplang.BaseType (_,i)) : doc = render i


let rec prtVarId _ (AbsDeeplang.VarId (_,i)) : doc = render i
and prtVarIdListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtVarId 0 x])
  | (_,x::xs) -> (concatD [prtVarId 0 x ; render "," ; prtVarIdListBNFC 0 xs])


let rec prtCode (i:int) (e : AbsDeeplang.code) : doc = match e with
       AbsDeeplang.Declares declare -> prPrec i 0 (concatD [prtDeclare 0 declare])
  |    AbsDeeplang.Defines define -> prPrec i 0 (concatD [prtDefine 0 define])
  |    AbsDeeplang.Statements statement -> prPrec i 0 (concatD [prtStatement 0 statement])
  |    AbsDeeplang.Expressions expression -> prPrec i 0 (concatD [prtExpression 0 expression ; render ";"])
  |    AbsDeeplang.Unit  -> prPrec i 0 (concatD [])

and prtCodeListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtCode 0 x])
  | (_,x::xs) -> (concatD [prtCode 0 x ; prtCodeListBNFC 0 xs])
and prtTypeT (i:int) (e : AbsDeeplang.typeT) : doc = match e.shape with
       AbsDeeplang.TypeFixLenArray (type_, integer) -> prPrec i 0 (concatD [render "[" ; prtTypeT 0 type_ ; render ";" ; prtInt 0 integer ; render "]"])
  |    AbsDeeplang.TypeArrow (type_1, type_2) -> prPrec i 0 (concatD [prtTypeT 0 type_1 ; render "->" ; prtTypeT 0 type_2])
  |    AbsDeeplang.TypeUnit  -> prPrec i 0 (concatD [render "()"])
  |    AbsDeeplang.TypeUnit2  -> prPrec i 0 (concatD [render "(" ; render ")"])
  |    AbsDeeplang.TypeTuple types -> prPrec i 0 (concatD [render "(" ; prtTypeTListBNFC 0 types ; render ")"])
  |    AbsDeeplang.TypePrimitive basetype -> prPrec i 0 (concatD [prtBaseType 0 basetype])
  |    AbsDeeplang.TypeX typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid])

and prtTypeTListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtTypeT 0 x])
  | (_,x::xs) -> (concatD [prtTypeT 0 x ; render "," ; prtTypeTListBNFC 0 xs])
and prtMVarId (i:int) (e : AbsDeeplang.mVarId) : doc = match e with
       AbsDeeplang.MutVar (mut, varid) -> prPrec i 0 (concatD [prtMUT 0 mut ; prtVarId 0 varid])
  |    AbsDeeplang.ImmutVar varid -> prPrec i 0 (concatD [prtVarId 0 varid])


and prtDeclare (i:int) (e : AbsDeeplang.declare) : doc = match e with
       AbsDeeplang.DecFunc (fun_, varid, args, rettype) -> prPrec i 0 (concatD [prtFUN 0 fun_ ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype])
  |    AbsDeeplang.InterfaceNoExt (interface, interfacename, methods) -> prPrec i 0 (concatD [prtINTERFACE 0 interface ; prtInterfaceName 0 interfacename ; prtMethods 0 methods])
  |    AbsDeeplang.InterfaceExt (interface, interfacename, extends, interfacenames, methods) -> prPrec i 0 (concatD [prtINTERFACE 0 interface ; prtInterfaceName 0 interfacename ; prtEXTENDS 0 extends ; prtInterfaceNameListBNFC 0 interfacenames ; prtMethods 0 methods])


and prtArgs (i:int) (e : AbsDeeplang.args) : doc = match e with
       AbsDeeplang.ArgUnit  -> prPrec i 0 (concatD [render "(" ; render ")"])
  |    AbsDeeplang.ArgUnit2  -> prPrec i 0 (concatD [render "()"])
  |    AbsDeeplang.ArgExist args -> prPrec i 0 (concatD [render "(" ; prtArgListBNFC 0 args ; render ")"])


and prtArg (i:int) (e : AbsDeeplang.arg) : doc = match e with
       AbsDeeplang.ArgCons (varid, type_) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])

and prtArgListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtArg 0 x])
  | (_,x::xs) -> (concatD [prtArg 0 x ; render "," ; prtArgListBNFC 0 xs])
and prtRetType (i:int) (e : AbsDeeplang.retType) : doc = match e with
       AbsDeeplang.RetUnit  -> prPrec i 0 (concatD [])
  |    AbsDeeplang.RetExist type_ -> prPrec i 0 (concatD [render "->" ; prtTypeT 0 type_])


and prtInterfaceName (i:int) (e : AbsDeeplang.interfaceName) : doc = match e with
       AbsDeeplang.InterfaceNames typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid])

and prtInterfaceNameListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtInterfaceName 0 x])
  | (_,x::xs) -> (concatD [prtInterfaceName 0 x ; render "," ; prtInterfaceNameListBNFC 0 xs])
and prtMethods (i:int) (e : AbsDeeplang.methods) : doc = match e with
       AbsDeeplang.InterfaceMethodUnit  -> prPrec i 0 (concatD [render "{}"])
  |    AbsDeeplang.InterfaceMethodExist methods -> prPrec i 0 (concatD [render "{" ; prtMethodTListBNFC 0 methods ; render "}"])


and prtMethodT (i:int) (e : AbsDeeplang.methodT) : doc = match e with
       AbsDeeplang.InterfaceMethod (fun_, varid, args, rettype) -> prPrec i 0 (concatD [prtFUN 0 fun_ ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render ";"])
  |    AbsDeeplang.ADTMethod (fun_, varid, args, rettype, statements) -> prPrec i 0 (concatD [prtFUN 0 fun_ ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])

and prtMethodTListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtMethodT 0 x])
  | (_,x::xs) -> (concatD [prtMethodT 0 x ; prtMethodTListBNFC 0 xs])
and prtDefine (i:int) (e : AbsDeeplang.define) : doc = match e with
       AbsDeeplang.DefFunc function_ -> prPrec i 0 (concatD [prtFunctionT 0 function_])
  |    AbsDeeplang.ADT (type_, typeid, constructors) -> prPrec i 0 (concatD [prtTYPE 0 type_ ; prtTypeId 0 typeid ; render "[" ; prtConstructorListBNFC 0 constructors ; render "]"])
  |    AbsDeeplang.Struct (type_, typeid, structfields) -> prPrec i 0 (concatD [prtTYPE 0 type_ ; prtTypeId 0 typeid ; render "{" ; prtStructFieldListBNFC 0 structfields ; render "}"])
  |    AbsDeeplang.DefVar (let_, mutflag, typedmatcher, rhs) -> prPrec i 0 (concatD [prtLET 0 let_ ; prtMutFlag 0 mutflag ; prtTypedMatcher 0 typedmatcher ; prtRHS 0 rhs ; render ";"])
  |    AbsDeeplang.DefType (type_, typeid, args) -> prPrec i 0 (concatD [prtTYPE 0 type_ ; prtTypeId 0 typeid ; prtArgs 0 args ; render ";"])
  |    AbsDeeplang.InterfaceImpl (impl, interfacename, for_, type_, functions) -> prPrec i 0 (concatD [prtIMPL 0 impl ; prtInterfaceName 0 interfacename ; prtFOR 0 for_ ; prtTypeT 0 type_ ; prtFunctions 0 functions])
  |    AbsDeeplang.RawImpl (impl, type_, functions) -> prPrec i 0 (concatD [prtIMPL 0 impl ; prtTypeT 0 type_ ; prtFunctions 0 functions])


and prtFunctionT (i:int) (e : AbsDeeplang.functionT) : doc = match e with
       AbsDeeplang.FuncUnit (fun_, varid, args, rettype) -> prPrec i 0 (concatD [prtFUN 0 fun_ ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render "{}"])
  |    AbsDeeplang.Func (fun_, varid, args, rettype, statements) -> prPrec i 0 (concatD [prtFUN 0 fun_ ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])

and prtFunctionTListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtFunctionT 0 x])
  | (_,x::xs) -> (concatD [prtFunctionT 0 x ; prtFunctionTListBNFC 0 xs])
and prtConstructor (i:int) (e : AbsDeeplang.constructor) : doc = match e with
       AbsDeeplang.UnitCons typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid])
  |    AbsDeeplang.ParamCons (typeid, fields) -> prPrec i 0 (concatD [prtTypeId 0 typeid ; render "(" ; prtFieldListBNFC 0 fields ; render ")"])

and prtConstructorListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtConstructor 0 x])
  | (_,x::xs) -> (concatD [prtConstructor 0 x ; render "," ; prtConstructorListBNFC 0 xs])
and prtField (i:int) (e : AbsDeeplang.field) : doc = match e with
       AbsDeeplang.FieldCons (varid, type_) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])

and prtFieldListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtField 0 x])
  | (_,x::xs) -> (concatD [prtField 0 x ; render "," ; prtFieldListBNFC 0 xs])
and prtStructField (i:int) (e : AbsDeeplang.structField) : doc = match e with
       AbsDeeplang.BasicStructField field -> prPrec i 0 (concatD [prtField 0 field])
  |    AbsDeeplang.DelegateStructField (as_, field) -> prPrec i 0 (concatD [prtAS 0 as_ ; prtField 0 field])

and prtStructFieldListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtStructField 0 x])
  | (_,x::xs) -> (concatD [prtStructField 0 x ; render "," ; prtStructFieldListBNFC 0 xs])
and prtRHS (i:int) (e : AbsDeeplang.rHS) : doc = match e with
       AbsDeeplang.DefRHS expression -> prPrec i 0 (concatD [render "=" ; prtExpression 0 expression])
  |    AbsDeeplang.NilRHS  -> prPrec i 0 (concatD [])


and prtMutFlag (i:int) (e : AbsDeeplang.mutFlag) : doc = match e with
       AbsDeeplang.Mut mut -> prPrec i 0 (concatD [prtMUT 0 mut])
  |    AbsDeeplang.Immut  -> prPrec i 0 (concatD [])


and prtFunctions (i:int) (e : AbsDeeplang.functions) : doc = match e with
       AbsDeeplang.FunctionsUnit  -> prPrec i 0 (concatD [render "{}"])
  |    AbsDeeplang.FunctionsMany functions -> prPrec i 0 (concatD [render "{" ; prtFunctionTListBNFC 0 functions ; render "}"])


and prtStatement (i:int) (e : AbsDeeplang.statement) : doc = match e with
       AbsDeeplang.Block statements -> prPrec i 0 (concatD [render "{" ; prtStatementListBNFC 0 statements ; render "}"])
  |    AbsDeeplang.DefVarSt (let_, mutflag, typedmatcher, rhs) -> prPrec i 0 (concatD [prtLET 0 let_ ; prtMutFlag 0 mutflag ; prtTypedMatcher 0 typedmatcher ; prtRHS 0 rhs ; render ";"])
  |    AbsDeeplang.ExprSt expression -> prPrec i 0 (concatD [prtExpression 0 expression ; render ";"])
  |    AbsDeeplang.Return expression -> prPrec i 0 (concatD [render "return" ; prtExpression 0 expression ; render ";"])
  |    AbsDeeplang.If (if_, expression, statements, elsebody) -> prPrec i 0 (concatD [prtIF 0 if_ ; render "(" ; prtExpression 0 expression ; render ")" ; render "{" ; prtStatementListBNFC 0 statements ; render "}" ; prtElseBody 0 elsebody])
  |    AbsDeeplang.For (for_, matcher, in_, expression, statements) -> prPrec i 0 (concatD [prtFOR 0 for_ ; render "(" ; prtMatcher 0 matcher ; prtIN 0 in_ ; prtExpression 0 expression ; render ")" ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])
  |    AbsDeeplang.While (while_, expression, statements) -> prPrec i 0 (concatD [prtWHILE 0 while_ ; render "(" ; prtExpression 0 expression ; render ")" ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])
  |    AbsDeeplang.Match (match_, varid, matchbody) -> prPrec i 0 (concatD [prtMATCH 0 match_ ; render "(" ; prtVarId 0 varid ; render ")" ; render "{" ; prtMatchBody 0 matchbody ; render "}"])

and prtStatementListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtStatement 0 x])
  | (_,x::xs) -> (concatD [prtStatement 0 x ; prtStatementListBNFC 0 xs])
and prtElseBody (i:int) (e : AbsDeeplang.elseBody) : doc = match e with
       AbsDeeplang.NoElse  -> prPrec i 0 (concatD [])
  |    AbsDeeplang.Elif (else_, if_, expression, statements, elsebody) -> prPrec i 0 (concatD [prtELSE 0 else_ ; prtIF 0 if_ ; render "(" ; prtExpression 0 expression ; render ")" ; render "{" ; prtStatementListBNFC 0 statements ; render "}" ; prtElseBody 0 elsebody])
  |    AbsDeeplang.Else (else_, statements) -> prPrec i 0 (concatD [prtELSE 0 else_ ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])


and prtMatchBody (i:int) (e : AbsDeeplang.matchBody) : doc = match e with
       AbsDeeplang.MatchBodys matchcases -> prPrec i 0 (concatD [prtMatchCaseListBNFC 0 matchcases])


and prtMatchCase (i:int) (e : AbsDeeplang.matchCase) : doc = match e with
       AbsDeeplang.MatchCases (matcher, statements) -> prPrec i 0 (concatD [prtMatcher 0 matcher ; render "=>" ; render "{" ; prtStatementListBNFC 0 statements ; render "}"])

and prtMatchCaseListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtMatchCase 0 x])
  | (_,x::xs) -> (concatD [prtMatchCase 0 x ; prtMatchCaseListBNFC 0 xs])
and prtMatcher (i:int) (e : AbsDeeplang.matcher) : doc = match e with
       AbsDeeplang.TypedMatchers typedmatcher -> prPrec i 0 (concatD [prtTypedMatcher 0 typedmatcher])
  |    AbsDeeplang.TypelessMatchers typelessmatcher -> prPrec i 0 (concatD [prtTypelessMatcher 0 typelessmatcher])
  |    AbsDeeplang.AsVarMatch (matcher, as_, mvarid) -> prPrec i 0 (concatD [prtMatcher 0 matcher ; prtAS 0 as_ ; prtMVarId 0 mvarid])

and prtMatcherListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtMatcher 0 x])
  | (_,x::xs) -> (concatD [prtMatcher 0 x ; render "," ; prtMatcherListBNFC 0 xs])
and prtTypedMatcher (i:int) (e : AbsDeeplang.typedMatcher) : doc = match e with
       AbsDeeplang.Typed (typelessmatcher, type_) -> prPrec i 0 (concatD [prtTypelessMatcher 0 typelessmatcher ; render ":" ; prtTypeT 0 type_])


and prtTypelessMatcher (i:int) (e : AbsDeeplang.typelessMatcher) : doc = match e with
       AbsDeeplang.WildCardMatch  -> prPrec i 0 (concatD [render "_"])
  |    AbsDeeplang.ConsMatchUnit typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid ; render "()"])
  |    AbsDeeplang.ConsMatch (typeid, matcher) -> prPrec i 0 (concatD [prtTypeId 0 typeid ; render "(" ; prtMatcher 0 matcher ; render ")"])
  |    AbsDeeplang.TypelessVarMatch mvarid -> prPrec i 0 (concatD [prtMVarId 0 mvarid])
  |    AbsDeeplang.UnitMatch  -> prPrec i 0 (concatD [render "()"])
  |    AbsDeeplang.TupleMatch matchers -> prPrec i 0 (concatD [render "(" ; prtMatcherListBNFC 0 matchers ; render ")"])
  |    AbsDeeplang.LiteralMatch literal -> prPrec i 0 (concatD [prtLiteral 0 literal])
  |    AbsDeeplang.FieldMatchUnit typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid ; render "{}"])
  |    AbsDeeplang.FieldMatch (typeid, fieldmatchers) -> prPrec i 0 (concatD [prtTypeId 0 typeid ; render "{" ; prtFieldMatcherListBNFC 0 fieldmatchers ; render "}"])


and prtFieldMatcher (i:int) (e : AbsDeeplang.fieldMatcher) : doc = match e with
       AbsDeeplang.FieldMatchers (varid, typelessmatcher) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypelessMatcher 0 typelessmatcher])

and prtFieldMatcherListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtFieldMatcher 0 x])
  | (_,x::xs) -> (concatD [prtFieldMatcher 0 x ; render "," ; prtFieldMatcherListBNFC 0 xs])
and prtExpression (i:int) (e : AbsDeeplang.expression) : doc = match e with
       AbsDeeplang.ExpVar matcher -> prPrec i 12 (concatD [prtMatcher 0 matcher])
  |    AbsDeeplang.Literals literal -> prPrec i 12 (concatD [prtLiteral 0 literal])
  |    AbsDeeplang.Tuples expressions -> prPrec i 12 (concatD [render "(" ; prtExpressionListBNFC 0 expressions ; render ")"])
  |    AbsDeeplang.Array expressions -> prPrec i 12 (concatD [render "[" ; prtExpressionListBNFC 0 expressions ; render "]"])
  |    AbsDeeplang.StructInit (typeid, fieldinits) -> prPrec i 12 (concatD [prtTypeId 0 typeid ; render "{" ; prtFieldInitListBNFC 0 fieldinits ; render "}"])
  |    AbsDeeplang.ExpAssignment (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpAssignmentPlus (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "+=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpAssignmentMinus (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "-=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpAssignmentMul (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "*=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpAssignmentDiv (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "/=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpAssignmentMod (varid, expression) -> prPrec i 1 (concatD [prtVarId 0 varid ; render "%=" ; prtExpression 1 expression])
  |    AbsDeeplang.ExpLogicalOr (expression1, expression2) -> prPrec i 2 (concatD [prtExpression 2 expression1 ; render "||" ; prtExpression 3 expression2])
  |    AbsDeeplang.ExpLogicalAnd (expression1, expression2) -> prPrec i 3 (concatD [prtExpression 3 expression1 ; render "&&" ; prtExpression 4 expression2])
  |    AbsDeeplang.ExpLogicalNot expression -> prPrec i 4 (concatD [render "!" ; prtExpression 4 expression])
  |    AbsDeeplang.ExpLt (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render "<" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpLeq (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render "<=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpGt (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render ">" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpGeq (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render ">=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpEq (expression1, expression2) -> prPrec i 6 (concatD [prtExpression 7 expression1 ; render "==" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpNoteq (expression1, expression2) -> prPrec i 6 (concatD [prtExpression 7 expression1 ; render "!=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpLeftShift (expression1, expression2) -> prPrec i 7 (concatD [prtExpression 7 expression1 ; render "<<" ; prtExpression 8 expression2])
  |    AbsDeeplang.ExpRightShift (expression1, expression2) -> prPrec i 7 (concatD [prtExpression 7 expression1 ; render ">>" ; prtExpression 8 expression2])
  |    AbsDeeplang.ExpAdd (expression1, expression2) -> prPrec i 8 (concatD [prtExpression 8 expression1 ; render "+" ; prtExpression 9 expression2])
  |    AbsDeeplang.ExpSub (expression1, expression2) -> prPrec i 8 (concatD [prtExpression 8 expression1 ; render "-" ; prtExpression 9 expression2])
  |    AbsDeeplang.ExpMul (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "*" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpDiv (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "/" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpMod (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "%" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpApp (expression, expressions) -> prPrec i 11 (concatD [prtExpression 11 expression ; render "(" ; prtExpressionListBNFC 0 expressions ; render ")"])
  |    AbsDeeplang.ExpAppUnit expression -> prPrec i 11 (concatD [prtExpression 11 expression ; render "()"])
  |    AbsDeeplang.ExpNewObj (typeid, expressions) -> prPrec i 11 (concatD [prtTypeId 0 typeid ; render "(" ; prtExpressionListBNFC 0 expressions ; render ")"])
  |    AbsDeeplang.ExpNewObjUnit typeid -> prPrec i 11 (concatD [prtTypeId 0 typeid ; render "()"])
  |    AbsDeeplang.ExpMethod (expression, varid) -> prPrec i 11 (concatD [prtExpression 11 expression ; render "." ; prtVarId 0 varid])
  |    AbsDeeplang.ExpBracket expression -> prPrec i 13 (concatD [render "(" ; prtExpression 0 expression ; render ")"])

and prtExpressionListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpression 0 x])
  | (_,x::xs) -> (concatD [prtExpression 0 x ; render "," ; prtExpressionListBNFC 0 xs])
and prtLiteral (i:int) (e : AbsDeeplang.literal) : doc = match e with
       AbsDeeplang.String string -> prPrec i 0 (concatD [prtString 0 string])
  |    AbsDeeplang.Char char -> prPrec i 0 (concatD [prtChar 0 char])
  |    AbsDeeplang.Integer integer -> prPrec i 0 (concatD [prtInt 0 integer])
  |    AbsDeeplang.Float double -> prPrec i 0 (concatD [prtFloat 0 double])
  |    AbsDeeplang.True  -> prPrec i 0 (concatD [render "true"])
  |    AbsDeeplang.False  -> prPrec i 0 (concatD [render "false"])
  |    AbsDeeplang.LUnit  -> prPrec i 0 (concatD [render "()"])
  |    AbsDeeplang.AUnit  -> prPrec i 0 (concatD [render "[]"])


and prtFieldInit (i:int) (e : AbsDeeplang.fieldInit) : doc = match e with
       AbsDeeplang.FieldInitCons (varid, expression) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtExpression 0 expression])

and prtFieldInitListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtFieldInit 0 x])
  | (_,x::xs) -> (concatD [prtFieldInit 0 x ; render "," ; prtFieldInitListBNFC 0 xs])

