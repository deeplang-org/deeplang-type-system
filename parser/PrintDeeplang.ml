(* pretty-printer generated by the BNF converter *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 4

let indent (i: int) : string = "\n" ^ String.make i ' '

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let whitespace = match last with
        None -> ""
      | Some '{' -> indent i
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent i)
      | Some ';' -> indent i
      | (Some '[') |  (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
            "," | ")" | "]" -> ""
           | _ -> if String.trim s = "" then "" else " ") in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let rec prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let rec prtInt (_:int) (i:int) : doc = render (string_of_int i)



let rec prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let rec prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let rec prtTypeId _ (AbsDeeplang.TypeId i) : doc = render i


let rec prtVarId _ (AbsDeeplang.VarId i) : doc = render i



let rec prtCode (i:int) (e : AbsDeeplang.code) : doc = match e with
       AbsDeeplang.Declares declare -> prPrec i 0 (concatD [prtDeclare 0 declare])
  |    AbsDeeplang.Defines define -> prPrec i 0 (concatD [prtDefine 0 define])
  |    AbsDeeplang.Statements statement -> prPrec i 0 (concatD [prtStatement 0 statement])
  |    AbsDeeplang.Expressions expression -> prPrec i 0 (concatD [prtExpression 0 expression])
  |    AbsDeeplang.Unit  -> prPrec i 0 (concatD [])

and prtCodeListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtCode 0 x ; render ";" ; prtCodeListBNFC 0 xs])
and prtTypeT (i:int) (e : AbsDeeplang.typeT) : doc = match e with
       AbsDeeplang.TypeArray (type_, integer) -> prPrec i 0 (concatD [render "[" ; prtTypeT 0 type_ ; render ";" ; prtInt 0 integer ; render "]"])
  |    AbsDeeplang.TypeList type_ -> prPrec i 0 (concatD [render "[" ; prtTypeT 0 type_ ; render "]"])
  |    AbsDeeplang.TypeArrow (type_1, type_2) -> prPrec i 0 (concatD [prtTypeT 0 type_1 ; render "->" ; prtTypeT 0 type_2])
  |    AbsDeeplang.TypeBool  -> prPrec i 1 (concatD [render "bool"])
  |    AbsDeeplang.TypeTuple  -> prPrec i 1 (concatD [render "tuple"])
  |    AbsDeeplang.TypeUnit  -> prPrec i 1 (concatD [render "()"])
  |    AbsDeeplang.TypeI8  -> prPrec i 1 (concatD [render "i8"])
  |    AbsDeeplang.TypeI16  -> prPrec i 1 (concatD [render "i16"])
  |    AbsDeeplang.TypeI32  -> prPrec i 1 (concatD [render "i32"])
  |    AbsDeeplang.TypeI64  -> prPrec i 1 (concatD [render "i64"])
  |    AbsDeeplang.TypeU8  -> prPrec i 1 (concatD [render "u8"])
  |    AbsDeeplang.TypeU16  -> prPrec i 1 (concatD [render "u16"])
  |    AbsDeeplang.TypeU32  -> prPrec i 1 (concatD [render "u32"])
  |    AbsDeeplang.TypeU64  -> prPrec i 1 (concatD [render "u64"])
  |    AbsDeeplang.TypeF32  -> prPrec i 1 (concatD [render "f32"])
  |    AbsDeeplang.TypeF64  -> prPrec i 1 (concatD [render "f64"])
  |    AbsDeeplang.TypeChar  -> prPrec i 1 (concatD [render "char"])
  |    AbsDeeplang.TypeThis  -> prPrec i 1 (concatD [render "This"])
  |    AbsDeeplang.TypeX typeid -> prPrec i 2 (concatD [prtTypeId 0 typeid])


and prtVariable (i:int) (e : AbsDeeplang.variable) : doc = match e with
       AbsDeeplang.Variables varid -> prPrec i 0 (concatD [prtVarId 0 varid])

and prtVariableListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtVariable 0 x])
  | (_,x::xs) -> (concatD [prtVariable 0 x ; render "," ; prtVariableListBNFC 0 xs])
and prtDeclare (i:int) (e : AbsDeeplang.declare) : doc = match e with
       AbsDeeplang.DecImmut (varid, type_) -> prPrec i 0 (concatD [render "let" ; prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])
  |    AbsDeeplang.DecMut (varid, type_) -> prPrec i 0 (concatD [render "let" ; render "mut" ; prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])
  |    AbsDeeplang.DecFunc (varid, args, rettype) -> prPrec i 0 (concatD [render "fun" ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype])
  |    AbsDeeplang.InterfaceNoExt (interfacename, methods) -> prPrec i 0 (concatD [render "interface" ; prtInterfaceName 0 interfacename ; render "{" ; prtMethods 0 methods ; render "}"])
  |    AbsDeeplang.InterfaceExt (interfacename, interfacenames, methods) -> prPrec i 0 (concatD [render "interface" ; prtInterfaceName 0 interfacename ; render "extends" ; prtInterfaceNameListBNFC 0 interfacenames ; render "{" ; prtMethods 0 methods ; render "}"])


and prtArgs (i:int) (e : AbsDeeplang.args) : doc = match e with
       AbsDeeplang.ArgUnit  -> prPrec i 0 (concatD [render "(" ; render ")"])
  |    AbsDeeplang.ArgExist args -> prPrec i 0 (concatD [render "(" ; prtArgListBNFC 0 args ; render ")"])


and prtArg (i:int) (e : AbsDeeplang.arg) : doc = match e with
       AbsDeeplang.ArgCons (varid, type_) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])
  |    AbsDeeplang.Delegate (varid, type_) -> prPrec i 0 (concatD [render "as" ; prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])

and prtArgListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtArg 0 x])
  | (_,x::xs) -> (concatD [prtArg 0 x ; render "," ; prtArgListBNFC 0 xs])
and prtRetType (i:int) (e : AbsDeeplang.retType) : doc = match e with
       AbsDeeplang.RetUnit  -> prPrec i 0 (concatD [])
  |    AbsDeeplang.RetExist type_ -> prPrec i 0 (concatD [render "->" ; prtTypeT 0 type_])


and prtInterfaceName (i:int) (e : AbsDeeplang.interfaceName) : doc = match e with
       AbsDeeplang.InterfaceNames typeid -> prPrec i 0 (concatD [prtTypeId 0 typeid])

and prtInterfaceNameListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtInterfaceName 0 x])
  | (_,x::xs) -> (concatD [prtInterfaceName 0 x ; render "," ; prtInterfaceNameListBNFC 0 xs])
and prtMethods (i:int) (e : AbsDeeplang.methods) : doc = match e with
       AbsDeeplang.InterfaceMethodUnit  -> prPrec i 0 (concatD [render "{" ; render "}"])
  |    AbsDeeplang.InterfaceMethodExist methods -> prPrec i 0 (concatD [render "{" ; prtMethodTListBNFC 0 methods ; render "}"])


and prtMethodT (i:int) (e : AbsDeeplang.methodT) : doc = match e with
       AbsDeeplang.InterfaceMethod (varid, args, rettype) -> prPrec i 0 (concatD [render "fun" ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render ";"])
  |    AbsDeeplang.ADTMethod (varid, args, rettype, codes) -> prPrec i 0 (concatD [render "fun" ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])

and prtMethodTListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtMethodT 0 x])
  | (_,x::xs) -> (concatD [prtMethodT 0 x ; prtMethodTListBNFC 0 xs])
and prtDefine (i:int) (e : AbsDeeplang.define) : doc = match e with
       AbsDeeplang.InterfaceImpl (interfacename, type_, methods) -> prPrec i 0 (concatD [render "impl" ; prtInterfaceName 0 interfacename ; render "for" ; prtTypeT 0 type_ ; render "{" ; prtMethodTListBNFC 0 methods ; render "}"])
  |    AbsDeeplang.RawImpl (type_, methods) -> prPrec i 0 (concatD [render "impl" ; prtTypeT 0 type_ ; render "{" ; prtMethodTListBNFC 0 methods ; render "}"])
  |    AbsDeeplang.DefFunc (varid, args, rettype, codes) -> prPrec i 0 (concatD [render "fun" ; prtVarId 0 varid ; prtArgs 0 args ; prtRetType 0 rettype ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])
  |    AbsDeeplang.ADT (typeid, constructors, methods) -> prPrec i 0 (concatD [render "type" ; prtTypeId 0 typeid ; render "[" ; prtConstructorListBNFC 0 constructors ; render "]" ; prtMethods 0 methods])
  |    AbsDeeplang.DefVar (typedvar, expression) -> prPrec i 0 (concatD [render "let" ; prtTypedVar 0 typedvar ; render "=" ; prtExpression 0 expression])
  |    AbsDeeplang.DefType (typeid, args) -> prPrec i 0 (concatD [render "type" ; prtTypeId 0 typeid ; prtArgs 0 args])


and prtConstructor (i:int) (e : AbsDeeplang.constructor) : doc = match e with
       AbsDeeplang.Constructors (typeid, fields) -> prPrec i 0 (concatD [prtTypeId 0 typeid ; prtFields 0 fields])

and prtConstructorListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtConstructor 0 x])
  | (_,x::xs) -> (concatD [prtConstructor 0 x ; render "," ; prtConstructorListBNFC 0 xs])
and prtFields (i:int) (e : AbsDeeplang.fields) : doc = match e with
       AbsDeeplang.FieldUnit  -> prPrec i 0 (concatD [render "(" ; render ")"])
  |    AbsDeeplang.FieldExist fields -> prPrec i 0 (concatD [render "(" ; prtFieldListBNFC 0 fields ; render ")"])


and prtField (i:int) (e : AbsDeeplang.field) : doc = match e with
       AbsDeeplang.FieldCons (varid, type_) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])

and prtFieldListBNFC i es : doc = match (i, es) with
    (_,[x]) -> (concatD [prtField 0 x])
  | (_,x::xs) -> (concatD [prtField 0 x ; render "," ; prtFieldListBNFC 0 xs])
and prtTypedVar (i:int) (e : AbsDeeplang.typedVar) : doc = match e with
       AbsDeeplang.ImmutVar (varid, type_) -> prPrec i 0 (concatD [prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])
  |    AbsDeeplang.MutVar (varid, type_) -> prPrec i 0 (concatD [render "mut" ; prtVarId 0 varid ; render ":" ; prtTypeT 0 type_])


and prtStatement (i:int) (e : AbsDeeplang.statement) : doc = match e with
       AbsDeeplang.If (ifcondtion, codes) -> prPrec i 0 (concatD [render "if" ; render "(" ; prtIfCondtion 0 ifcondtion ; render ")" ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])
  |    AbsDeeplang.IfElse (ifcondtion, codes1, codes2) -> prPrec i 0 (concatD [render "if" ; render "(" ; prtIfCondtion 0 ifcondtion ; render ")" ; render "{" ; prtCodeListBNFC 0 codes1 ; render "}" ; render "else" ; render "{" ; prtCodeListBNFC 0 codes2 ; render "}"])
  |    AbsDeeplang.For (typedvar, expression, forcondition, forfinal, codes) -> prPrec i 0 (concatD [render "for" ; render "(" ; render "let" ; prtTypedVar 0 typedvar ; render "=" ; prtExpression 0 expression ; render ";" ; prtForCondition 0 forcondition ; render ";" ; prtForFinal 0 forfinal ; render ")" ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])
  |    AbsDeeplang.While (forcondition, codes) -> prPrec i 0 (concatD [render "while" ; render "(" ; prtForCondition 0 forcondition ; render ")" ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])
  |    AbsDeeplang.Return expression -> prPrec i 0 (concatD [render "return" ; prtExpression 0 expression])
  |    AbsDeeplang.Match (varid, matchbody) -> prPrec i 0 (concatD [render "match" ; render "(" ; prtVarId 0 varid ; render ")" ; render "{" ; prtMatchBody 0 matchbody ; render "}"])


and prtIfCondtion (i:int) (e : AbsDeeplang.ifCondtion) : doc = match e with
       AbsDeeplang.IfCondtions expression -> prPrec i 0 (concatD [prtExpression 0 expression])


and prtForInit (i:int) (e : AbsDeeplang.forInit) : doc = match e with
       AbsDeeplang.ForInitUnit  -> prPrec i 0 (concatD [])


and prtForCondition (i:int) (e : AbsDeeplang.forCondition) : doc = match e with
       AbsDeeplang.ForConditions expression -> prPrec i 0 (concatD [prtExpression 0 expression])


and prtForFinal (i:int) (e : AbsDeeplang.forFinal) : doc = match e with
       AbsDeeplang.ForFinals expression -> prPrec i 0 (concatD [prtExpression 0 expression])


and prtMatchBody (i:int) (e : AbsDeeplang.matchBody) : doc = match e with
       AbsDeeplang.MatchBodys matchcases -> prPrec i 0 (concatD [prtMatchCaseListBNFC 0 matchcases])


and prtMatchCase (i:int) (e : AbsDeeplang.matchCase) : doc = match e with
       AbsDeeplang.MatchCases (matcher, codes) -> prPrec i 0 (concatD [prtMatcher 0 matcher ; render "=>" ; render "{" ; prtCodeListBNFC 0 codes ; render "}"])

and prtMatchCaseListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtMatchCase 0 x ; prtMatchCaseListBNFC 0 xs])
and prtMatcher (i:int) (e : AbsDeeplang.matcher) : doc = match e with
       AbsDeeplang.WildCardMatch  -> prPrec i 0 (concatD [render "_"])
  |    AbsDeeplang.ConsMatch constructor -> prPrec i 0 (concatD [prtConstructor 0 constructor])
  |    AbsDeeplang.VarMatch typedvar -> prPrec i 0 (concatD [prtTypedVar 0 typedvar])
  |    AbsDeeplang.AsVarMatch (matcher, typedvar) -> prPrec i 0 (concatD [prtMatcher 0 matcher ; render "as" ; prtTypedVar 0 typedvar])


and prtExpression (i:int) (e : AbsDeeplang.expression) : doc = match e with
       AbsDeeplang.ExpVar variable -> prPrec i 12 (concatD [prtVariable 0 variable])
  |    AbsDeeplang.Literals literal -> prPrec i 12 (concatD [prtLiteral 0 literal])
  |    AbsDeeplang.ExpLogicalOr (expression1, expression2) -> prPrec i 2 (concatD [prtExpression 2 expression1 ; render "||" ; prtExpression 3 expression2])
  |    AbsDeeplang.ExpLogicalAnd (expression1, expression2) -> prPrec i 3 (concatD [prtExpression 3 expression1 ; render "&&" ; prtExpression 4 expression2])
  |    AbsDeeplang.ExpLogicalNot expression -> prPrec i 4 (concatD [render "!" ; prtExpression 4 expression])
  |    AbsDeeplang.ExpLt (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render "<" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpLeq (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render "<=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpGt (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render ">" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpGeq (expression1, expression2) -> prPrec i 5 (concatD [prtExpression 7 expression1 ; render ">=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpEq (expression1, expression2) -> prPrec i 6 (concatD [prtExpression 7 expression1 ; render "==" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpNoteq (expression1, expression2) -> prPrec i 6 (concatD [prtExpression 7 expression1 ; render "!=" ; prtExpression 7 expression2])
  |    AbsDeeplang.ExpLeftShift (expression1, expression2) -> prPrec i 7 (concatD [prtExpression 7 expression1 ; render "<<" ; prtExpression 8 expression2])
  |    AbsDeeplang.ExpRightShift (expression1, expression2) -> prPrec i 7 (concatD [prtExpression 7 expression1 ; render ">>" ; prtExpression 8 expression2])
  |    AbsDeeplang.ExpAdd (expression1, expression2) -> prPrec i 8 (concatD [prtExpression 8 expression1 ; render "+" ; prtExpression 9 expression2])
  |    AbsDeeplang.ExpSub (expression1, expression2) -> prPrec i 8 (concatD [prtExpression 8 expression1 ; render "-" ; prtExpression 9 expression2])
  |    AbsDeeplang.ExpMul (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "*" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpDiv (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "\\" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpMod (expression1, expression2) -> prPrec i 9 (concatD [prtExpression 9 expression1 ; render "%" ; prtExpression 10 expression2])
  |    AbsDeeplang.ExpApp (expression, expressions) -> prPrec i 11 (concatD [prtExpression 11 expression ; render "(" ; prtExpressionListBNFC 0 expressions ; render ")"])
  |    AbsDeeplang.ExpNewObj (typeid, expressions) -> prPrec i 11 (concatD [render "new" ; prtTypeId 0 typeid ; render "(" ; prtExpressionListBNFC 0 expressions ; render ")"])
  |    AbsDeeplang.ExpMethod (expression, variable) -> prPrec i 11 (concatD [prtExpression 11 expression ; render "." ; prtVariable 0 variable])
  |    AbsDeeplang.ExpBracket expression -> prPrec i 13 (concatD [render "(" ; prtExpression 0 expression ; render ")"])

and prtExpressionListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpression 0 x])
  | (_,x::xs) -> (concatD [prtExpression 0 x ; render "," ; prtExpressionListBNFC 0 xs])
and prtLiteral (i:int) (e : AbsDeeplang.literal) : doc = match e with
       AbsDeeplang.String string -> prPrec i 0 (concatD [prtString 0 string])
  |    AbsDeeplang.Integer integer -> prPrec i 0 (concatD [prtInt 0 integer])
  |    AbsDeeplang.True  -> prPrec i 0 (concatD [render "true"])
  |    AbsDeeplang.False  -> prPrec i 0 (concatD [render "false"])


and prtMacro (i:int) (e : AbsDeeplang.macro) : doc = match e with
       AbsDeeplang.ArrayMatch codes -> prPrec i 0 (concatD [render "match" ; render "(" ; prtCodeListBNFC 0 codes ; render ")"])



