module SkelDeeplang = struct

(* OCaml module generated by the BNF converter *)

open AbsDeeplang

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transTypeId (x : typeId) : result = match x with
    TypeId string -> failure x


and transVarId (x : varId) : result = match x with
    VarId string -> failure x


and transCode (x : code) : result = match x with
    Declares declare -> failure x
  | Defines define -> failure x
  | Statements statement -> failure x
  | Expressions expression -> failure x
  | Unit  -> failure x


and transType (x : typeT) : result = match x with
    TypeArray (type', integer) -> failure x
  | TypeList type' -> failure x
  | TypeArrow (type'0, type') -> failure x
  | TypeBool  -> failure x
  | TypeTuple  -> failure x
  | TypeUnit  -> failure x
  | TypeI8  -> failure x
  | TypeI16  -> failure x
  | TypeI32  -> failure x
  | TypeI64  -> failure x
  | TypeU8  -> failure x
  | TypeU16  -> failure x
  | TypeU32  -> failure x
  | TypeU64  -> failure x
  | TypeF32  -> failure x
  | TypeF64  -> failure x
  | TypeChar  -> failure x
  | TypeThis  -> failure x
  | TypeX typeid -> failure x


and transVariable (x : variable) : result = match x with
    Variables varid -> failure x


and transDeclare (x : declare) : result = match x with
    DecImmut (varid, type') -> failure x
  | DecMut (varid, type') -> failure x
  | DecFunc (varid, args, rettype) -> failure x
  | InterfaceNoExt (interfacename, methods) -> failure x
  | InterfaceExt (interfacename, interfacenames, methods) -> failure x


and transArgs (x : args) : result = match x with
    ArgUnit  -> failure x
  | ArgExist args -> failure x


and transArg (x : arg) : result = match x with
    ArgCons (varid, type') -> failure x
  | Delegate (varid, type') -> failure x


and transRetType (x : retType) : result = match x with
    RetUnit  -> failure x
  | RetExist type' -> failure x


and transInterfaceName (x : interfaceName) : result = match x with
    InterfaceNames typeid -> failure x


and transMethods (x : methods) : result = match x with
    InterfaceMethodUnit  -> failure x
  | InterfaceMethodExist methods -> failure x


and transMethod (x : methodT) : result = match x with
    InterfaceMethod (varid, args, rettype) -> failure x
  | ADTMethod (varid, args, rettype, codes) -> failure x


and transDefine (x : define) : result = match x with
    InterfaceImpl (interfacename, type', methods) -> failure x
  | RawImpl (type', methods) -> failure x
  | DefFunc (varid, args, rettype, codes) -> failure x
  | ADT (typeid, constructors, methods) -> failure x
  | DefVar (typedvar, expression) -> failure x
  | DefType (typeid, args) -> failure x


and transConstructor (x : constructor) : result = match x with
    Constructors (typeid, fields) -> failure x


and transFields (x : fields) : result = match x with
    FieldUnit  -> failure x
  | FieldExist fields -> failure x


and transField (x : field) : result = match x with
    FieldCons (varid, type') -> failure x


and transTypedVar (x : typedVar) : result = match x with
    ImmutVar (varid, type') -> failure x
  | MutVar (varid, type') -> failure x


and transStatement (x : statement) : result = match x with
    If (ifcondtion, codes) -> failure x
  | IfElse (ifcondtion, codes0, codes) -> failure x
  | For (typedvar, expression, forcondition, forfinal, codes) -> failure x
  | While (forcondition, codes) -> failure x
  | Return expression -> failure x
  | Match (varid, matchbody) -> failure x


and transIfCondtion (x : ifCondtion) : result = match x with
    IfCondtions expression -> failure x


and transForInit (x : forInit) : result = match x with
    ForInitUnit  -> failure x


and transForCondition (x : forCondition) : result = match x with
    ForConditions expression -> failure x


and transForFinal (x : forFinal) : result = match x with
    ForFinals expression -> failure x


and transMatchBody (x : matchBody) : result = match x with
    MatchBodys matchcases -> failure x


and transMatchCase (x : matchCase) : result = match x with
    MatchCases (matcher, codes) -> failure x


and transMatcher (x : matcher) : result = match x with
    WildCardMatch  -> failure x
  | ConsMatch constructor -> failure x
  | VarMatch typedvar -> failure x
  | AsVarMatch (matcher, typedvar) -> failure x


and transExpression (x : expression) : result = match x with
    ExpVar variable -> failure x
  | Literals literal -> failure x
  | ExpLogicalOr (expression0, expression) -> failure x
  | ExpLogicalAnd (expression0, expression) -> failure x
  | ExpLogicalNot expression -> failure x
  | ExpLt (expression0, expression) -> failure x
  | ExpLeq (expression0, expression) -> failure x
  | ExpGt (expression0, expression) -> failure x
  | ExpGeq (expression0, expression) -> failure x
  | ExpEq (expression0, expression) -> failure x
  | ExpNoteq (expression0, expression) -> failure x
  | ExpLeftShift (expression0, expression) -> failure x
  | ExpRightShift (expression0, expression) -> failure x
  | ExpAdd (expression0, expression) -> failure x
  | ExpSub (expression0, expression) -> failure x
  | ExpMul (expression0, expression) -> failure x
  | ExpDiv (expression0, expression) -> failure x
  | ExpMod (expression0, expression) -> failure x
  | ExpApp (expression, expressions) -> failure x
  | ExpNewObj (typeid, expressions) -> failure x
  | ExpMethod (expression, variable) -> failure x
  | ExpBracket expression -> failure x


and transLiteral (x : literal) : result = match x with
    String string -> failure x
  | Integer integer -> failure x
  | True  -> failure x
  | False  -> failure x


and transMacro (x : macro) : result = match x with
    ArrayMatch codes -> failure x



end
