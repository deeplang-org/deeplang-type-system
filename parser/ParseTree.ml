

(** This module defines the abstract syntax of deeplang.
    The syntax tree will be used for all subsequent compiler passes,
    until code generation. *)


(** {1 Helper Definitions} *)


(** [src_span] is a region in some source file.
    Used to report error messages *)
type src_span =
    { file  : string (** source file name *)
    ; row_s : int    (** row number of the start of the region *)
    ; col_s : int    (** column number of the start of the region *)
    ; row_e : int    (** row number of the end of the region *)
    ; col_e : int    (** column number of the end of the region *) }

type variable     = string
type func_name    = string
type struct_field = string
type adt_label    = string
type typ_name     = string
type method_name  = string
type intf_name    = string


(** a globally unique id for {e variables} *)
type symbol = Symbol of int [@@unboxed]


(** [NodeId] contains types for unique ids
    for various kinds of AST nodes.
    Can be used to attach extra data to AST nodes,
    via an external table. *)
module NodeId = struct
    type pattern = PatId  of int [@@unboxed]
    type expr    = ExprId of int [@@unboxed]
    type stmt    = StmtId of int [@@unboxed]
    type impl    = ImplId of int [@@unboxed]
    type func    = FuncId of int [@@unboxed]
end



(** {1 Types } *)

type int_typ_sign = Signed | Unsigned
type int_typ_size = ISize_8 | ISize_16 | ISize_32 | ISize_64

type float_typ_size = FSize_32 | FSize_64


(** For types internally generated by the compiler,
    [span] should be [None]. *)
type typ =
    { shape : typ_shape
    ; span  : src_span option }

(** [typ_shape] declares the structure of deeplang types *)
and typ_shape =
    | TyVar   of string
    | TyUnit
    | TyBool
    | TyInt   of int_typ_sign * int_typ_size
    | TyFloat of float_typ_size
    | TyChar
    | TyThis
    | TyArray of typ * int
    | TyTuple of typ list
    (* user-defined types with optional type arguments *)
    | TyNamed of typ_name * typ list



(** {1 Patterns} *)

type mutability = Imm | Mut

type var_pattern =
    { vpat_mut  : mutability
    ; vpat_typ  : typ option
    ; vpat_name : variable
    ; vpat_symb : symbol }

type pattern =
    { shape  : pattern_shape
    ; pat_id : NodeId.pattern
    ; span   : src_span }

and pattern_shape =
    | PatWildcard
    | PatVar    of var_pattern
    | PatAs     of pattern * var_pattern
    | PatADT    of adt_label * pattern list
    | PatStruct of typ_name * (struct_field * pattern) list
    | PatTuple  of pattern list


(** {1 Expressions} *)

type literal =
    | LitBool   of bool
    | LitInt    of int
    | LitFloat  of float
    (** 16-bit *)
    | LitChar   of int
    | LitString of string



type unary_op =
    | UnOpNeg | UnOpNot

(** Some notes on [BinOpAssign]:
    - [BinOpAssign None] is normal assignment
    - [BinOpAssign Add] is "+=", [BinOpAssign Sub] is "-=", etc.
    - Not all operators have corresponding assignment operators
    in the parser. This is just a simplification of AST definition *)
type binary_op =
    | BinOpLt  | BinOpLeq | BinOpGt | BinOpGeq
    | BinOpEq | BinOpNeq
    | BinOpLOr | BinOpLAnd | BinOpLNot
    | BinOpLShift | BinOpRShift
    | BinOpAdd | BinOpSub | BinOpMul | BinOpDiv | BinOpMod
    | BinOpAssign of binary_op option



type expr =
    { shape   : expr_shape
    ; expr_id : NodeId.expr
    ; span    : src_span }

and expr_shape =
    | ExpLit    of literal
    | ExpVar    of variable
    | ExpUnOp   of unary_op * expr
    | ExpBinOp  of binary_op * expr * expr
    | ExpTuple  of expr list
    | ExpAdt    of adt_label * expr list
    | ExpStruct of typ_name * (struct_field * expr) list
    | ExpField  of expr * struct_field
    | ExpThis
    | ExpApp    of func_name * expr list
    | ExpMethod of expr * method_name * expr list
    | ExpIf     of expr * expr * expr
    | ExpMatch  of expr * (pattern * expr) list



(** {1 Statements} *)

type stmt =
    { shape   : stmt_shape
    ; stmt_id : NodeId.stmt
    ; span    : src_span }

and stmt_shape =
    | StmtSeq      of stmt list
    | StmtExpr     of expr
    | StmtDecl     of pattern * expr
    | StmtIf       of expr * stmt * stmt
    | StmtFor      of (stmt * expr * stmt) * stmt
    | StmtForRange of (pattern * expr) * stmt
    | StmtWhile    of expr * stmt
    | StmtMatch    of expr * (pattern * stmt) list
    | StmtReturn   of expr
    | StmtBreak
    | StmtContinue




(** {1 Top Level Clauses} *)

type global_variable_def =
    { gvar_name  : variable
    ; gvar_id    : symbol
    ; gvar_value : expr }


type func_arg =
    { farg_name : variable
    ; farg_symb : symbol
    ; farg_typ  : typ }

type func_decl =
    { func_decl_name : func_name
    ; func_decl_args : func_arg list
    ; func_decl_id   : NodeId.func
    ; func_decl_ret  : typ }

type func_impl = func_decl * stmt



type struct_def_field =
    | StructField    of struct_field * typ
    | StructDelegate of struct_field * typ

type struct_def =
    { struct_name   : typ_name
    ; struct_fields : struct_def_field list }


type adt_def =
    { adt_name     : typ_name
    ; adt_branches : (adt_label * typ) list }


type interface_decl =
    { intf_decl_name    : intf_name
    ; intf_decl_methods : func_decl list }

type methods_impl =
    { impl_intf : intf_name option
    ; impl_typ  : typ
    ; impl_id   : NodeId.impl
    ; impl_methods : func_impl list }



type top_clause =
    { shape : top_clause_shape
    ; span  : src_span }

and top_clause_shape =
    | StructDef     of struct_def
    | ADTDef        of adt_def
    | InterfaceDecl of interface_decl
    | MethodsImpl   of methods_impl
    | FunctionDef   of func_impl
    | GlobalVarDef  of global_variable_def
