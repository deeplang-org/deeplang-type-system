

(** This module defines the abstract syntax of deeplang.
    The syntax tree will be used for all subsequent compiler passes,
    until code generation. *)

(** The {e DISCUSSION ONLY} labels below are constructs that need
    further discussion/clarification. *)


(** {1 Helper Definitions} *)

(** [src_span] is a region in some source file.
    Used to report error messages *)
type src_span =
    { file  : string (** source file name *)
    ; row_s : int    (** row number of the start of the region *)
    ; col_s : int    (** column number of the start of the region *)
    ; row_e : int    (** row number of the end of the region *)
    ; col_e : int    (** column number of the end of the region *) }

type variable     = string
type struct_field = string
type adt_label    = string
type method_name  = string
type intf_name    = string
type func_name    = string


(** [Symbols] contains types for unique {e symbol id}
    of various kinds of {e declarations}. *)
module Symbols = struct
    type typ_var   = TVarSymb    of int [@@unboxed]
    type variable  = VarSymb     of int [@@unboxed]
    type typ_name  = TypNameSymb of int [@@unboxed]
    type intf      = IntfSymb    of int [@@unboxed]
    type func      = FuncSymb    of int [@@unboxed]
end


(** [NodeId] contains types for unique ids
    for various kinds of AST nodes.
    Can be used to attach extra data to AST nodes,
    via an external table.
    {e DISCUSSION WANTED}:
    - separate variable usage ids and node ids? *)
module NodeId = struct
    type typ_var   = TVarId     of int [@@unboxed]
    type typ_name  = TypNameId  of int [@@unboxed]
    (** [NodeId.typ_var] and [NodeId.typ_name] are used for scope
        resolution of type variables and type names. *)

    type pattern   = PatId      of int [@@unboxed]
    type expr      = ExprId     of int [@@unboxed]
    type stmt      = StmtId     of int [@@unboxed]
    type intf_impl = IntfImplId of int [@@unboxed]
    type func_impl = FuncImplId of int [@@unboxed]
end



(** {1 Types } *)

type int_typ_sign = Signed | Unsigned
type int_typ_size = ISize_8 | ISize_16 | ISize_32 | ISize_64

type float_typ_size = FSize_32 | FSize_64


type typ_var =
    { tvar_id   : NodeId.typ_var
    ; tvar_name : string option }

type typ_name =
    { tname_id   : NodeId.typ_name
    ; tname_name : string }

(** The abstract syntax of deeplang types.
    The name is [typ] to avoid conflict with OCaml's builtin keyword.
    [typ] only declares extra data stored with each node,
    the structure of deeplang types are defined in [typ_shape]
    For types internally generated by the compiler,
    [span] should be [None]. *)
type typ =
    { shape : typ_shape
    ; span  : src_span option }

(** [typ_shape] declares the structure of deeplang types
    {e DISCUSSION WANTED}:
    - tuple types? *)
and typ_shape =
    | TyVar   of typ_var
    | TyUnit
    | TyBool
    | TyInt   of int_typ_sign * int_typ_size
    | TyFloat of float_typ_size
    | TyChar
    | TyThis
    | TyArray of typ * int
    (* user-defined types with optional type arguments *)
    | TyNamed of typ_name * typ list



(** {1 Patterns} *)

type pattern =
    { shape  : pattern_shape
    ; pat_id : NodeId.pattern
    ; span   : src_span }

and pattern_shape =
    | PatWildcard
    | PatVar    of variable
    | PatADT    of adt_label * pattern list
    | PatStruct of typ_name * (struct_field * pattern) list


(** {1 Expressions} *)

type literal =
    | LitBool   of bool
    | LitInt    of int
    | LitFloat  of float
    | LitString of string



(** {e DISCUSSION WANTED}:
    - Should we have the ++/-- operators? *)
type unary_op =
    | UnOpNeg | UnOpNot

(** Some notes on [BinOpAssign]:
    - [BinOpAssign None] is normal assignment
    - [BinOpAssign Add] is "+=", [BinOpAssign Sub] is "-=", etc.
    - Not all operators have corresponding assignment operators
    in the parser. This is just a simplification of AST definition *)
type binary_op =
    | BinOpLt  | BinOpLeq | BinOpGt | BinOpGeq
    | BinOpEq | BinOpNeq
    | BinOpLOr | BinOpLAnd | BinOpLNot
    | BinOpLShift | BinOpRShift
    | BinOpAdd | BinOpSub | BinOpMul | BinOpDiv | BinOpMod
    | BinOpAssign of binary_op option



type expr =
    { shape   : expr_shape
    ; expr_id : NodeId.expr
    ; span    : src_span }

(** {e DISCUSSION WANTED}
    - struct creation: `new` or bracket?
    - qualified names? (e.g. [TypeName::methodName])
    - clarity array macro *)
and expr_shape =
    | ExpLit    of literal
    | ExpVar    of variable
    | ExpUnOp   of unary_op * expr
    | ExpBinOp  of binary_op * expr * expr
    | ExpApp    of func_name * expr list
    | ExpNew    of typ_name * expr list
    | ExpField  of expr * struct_field
    | ExpMethod of expr * method_name * expr list
    | ExpIf     of expr * expr * expr
    | ExpMatch  of expr * (pattern * expr) list



(** {1 Statements} *)
type mutability = Imm | Mut

type declaration =
    { decl_name  : string
    ; decl_mut   : mutability
    ; decl_symb  : Symbols.variable
    ; decl_typ   : typ option
    ; decl_value : expr }


type stmt =
    { shape   : stmt_shape
    ; stmt_id : NodeId.stmt
    ; span    : src_span }

(** {e DISCUSSION WANTED}:
    - for loop: range/iterator based loops? *)
and stmt_shape =
    | StmtSeq    of stmt list
    | StmtExpr   of expr
    | StmtDecl   of declaration
    | StmtIf     of expr * stmt * stmt
    | StmtFor    of (stmt * expr * stmt) * stmt
    | StmtWhile  of expr * stmt
    | StmtMatch  of expr * (pattern * stmt) list
    | StmtReturn of expr
    | StmtBreak
    | StmtContinue




(** {1 Top Level Expressions } *)
type global_variable_def =
    { gvar_name  : variable
    ; gvar_id    : Symbols.variable
    ; gvar_value : expr }


type func_arg =
    { farg_name : variable
    ; farg_symb : Symbols.variable
    ; farg_typ  : typ }

type func_decl =
    { func_decl_name : func_name
    ; func_decl_symb : NodeId.func_impl
    ; func_decl_args : func_arg list
    ; func_decl_ret  : typ }

(** {e DISCUSSION WANTED}:
    - should the return type annotation be optional? *)
type func_impl =
    { func_impl_name : func_name
    ; func_impl_id   : NodeId.func_impl
    ; func_impl_args : func_arg list
    ; func_impl_ret  : typ
    ; func_impl_body : stmt }



type struct_def_field =
    | StructField    of struct_field * typ
    | StructDelegate of struct_field * typ

type struct_def =
    { struct_name   : typ_name
    ; struct_symb   : Symbols.typ_name
    ; struct_fields : struct_def_field list }


(** {e DISCUSSION WANTED}:
    - scoping rules for ADT? *)
type adt_def =
    { adt_name     : typ_name
    ; adt_symb     : Symbols.typ_name
    ; adt_branches : (adt_label * typ) list }


(** {e DISCUSSION WANTED}:
    Should we support:
    - generic interface
    - interface dependency
    - default implementation *)
type interface_decl =
    { intf_decl_name    : intf_name
    ; intf_decl_symb    : Symbols.intf
    ; intf_decl_methods : func_decl list }

type interface_impl =
    { intf_impl_name    : intf_name
    ; intf_impl_id      : NodeId.intf_impl
    ; intf_impl_methods : func_impl list }


type top_expr =
    { shape : top_expr_shape
    ; span  : src_span }

(** The type of top level expressions. *)
and top_expr_shape =
    | DefStruct     of struct_def
    | DefADT        of adt_def
    | DeclInterface of interface_decl
    | ImplInterface of interface_impl
    | DefFunction   of Symbols.func * func_impl
    | DefVariable   of global_variable_def
