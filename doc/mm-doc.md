# Deeplang内存管理文档

Deeplang是一门面向IoT的编程语言。
为了帮助用户在可用内存极少的环境下方便地编写程序，
Deeplang提供了多种不同的内存管理方式，
供用户针对自己的需求进行选择。

## 值类型
在Deeplang中，可以低开销地任意拷贝的类型称为值类型。
值类型一般分配在栈上，
在传递时直接发生拷贝，
因而不会产生任何内存安全和内存泄漏问题。

Deeplang中，以下的类型永远都是值类型：

- 所有整数类型、浮点数类型、和单个字符类型

以下的类型永远**不是**值类型
- 数组、字符串
- 某些分支携带了额外数据的ADT
- 含有非值类型域的结构体

对于以下的自定义类型，
用户可以在类型声明时选择是否希望该类型成为值类型：

- 所有分支都不携带额外数据的ADT
- 所有域都是值类型的结构体

由于值类型的特性，其使用不受任何限制。
但如果需要以“按引用传递”的方式传递一个值类型，
例如让一个函数修改一个整数，并让调用者使用修改后的结果，
需要借助后面的借用机制。

## 唯一所有权
在Deeplang中，**不是**值类型的类型，
例如数组、字符串，
不能被随意复制。
假设`T`不是值类型，
那么类型`T`的值任何时候都只能有一个唯一的所有者。
这意味着传递类型为`T`的值时，
原来的所有者会丢失所有权，不能再使用。例如：

    let x : [int; 1000] = ...;
    let y = x; // x的所有权被移交给了y
    /* print(x); */ // 会触发编译错误，因为x已经交出了自己的所有权，不能再被使用
    print(y); // y此时拥有所有权，因此可以被使用

由于唯一所有权，
每一个`T`的值在任何时候都只有来自所有者的一份引用，
当所有者不再被需要时，就可以安全地直接释放`T`使用的内存。
此外，由于唯一所有权，
类型`T`的值不会被隐式地拷贝，产生较大的开销。
因此，唯一所有权保证了安全、高效的内存管理。

## 借用与借用规则
尽管唯一所有权能够保证安全高效的内存管理，
它对数据的使用提出了过强的限制。
例如，如下的代码会报错：

    let x : [int; 1000] = ...;
    print(x); // x的所有权被转交给了print，并消失了！
    print(x); // x已经失去了所有权，会触发编译错误

这种限制显然是过强的。
为了改善唯一所有权的可用性，
Deeplang中可以将所有权**临时借出**，
并通过不同的**使用权限**来访问数据。
如果`T`是一个类型，
那么当一段程序可以访问内存中一段类型为`T`的数据`v`时，
它对`v`可能有如下几种使用权限（语法是暂定的）：

- `T`：这段程序是`v`的所有者
- `&T`：这段程序对`v`有**临时借用**的、**只读**的使用权限
- `&mut T`：这段程序对`v`有**临时借用**的、可以**读写**的使用权限
- `rc T`：这段程序是`v`的多个**共享**的所有者中的一个。
为了保证内存安全，Deeplang使用引用计数动态管理这段数据的内存。

然而，为了保证内存安全，
对数据的借用与不同的使用权限之间必须满足一些要求。
下面一一加以说明与解释：

1. 对数据的使用不能超出其使用权限允许的范围。
例如，持有只读权限时不能修改数据。
1. 权限之间有大小关系`T > &mut T > &T`。
出借权限时，不能凭空造出权限。
否则，就会违反唯一所有者或其他借用相关的规则。
1. 任何时候，只能同时有一份写入权限，或是多份只读权限，
两者不能同时存在。
考虑一个结构体`{ x: value1, y : value2 }`，
如果对它同时有一份写入权限`a`和一份读取或写入的权限`b`，
那么用写入权限`a`把整个结构体覆盖后，
利用`b`读取或写入结构体中的域都会导致内存安全错误。
1. 当一份使用权限即将被收回（例如其作用域结束）
或是即将被写入时，它出借的所有权限必须被收回。

上述几条规则能够保证对借用的使用是内存安全的。
Deeplang编译器能够自动检查程序是否遵守上述借用规则，
并在程序违反借用规则时汇报详细、易读的错误信息。
引用计数的支持情况较为复杂，在下面详细讨论。


## 引用计数
当程序的逻辑比较复杂，某段数据的所有者并不清楚时，
牺牲一部分性能，使用动态的内存管理方式可能是更合理的选择。
在这些场景下，Deeplang提供了语言内建的引用计数支持。

在Deeplang中，`rc T`代表对一段由Deeplang使用引用计数的方式管理的、
类型为`T`的数据的，共享的所有者权限。
Deeplang为动态地维护当前这段数据有几个不同的所有者。
当新的所有者产生时，Deeplang自动增加引用计数。
当一个所有者死亡时，Deeplang自动减少引用计数。
当最后一个所有者死亡，即引用计数归零时，Deeplang自动释放这段数据占用的内存。
由于可以有多个所有者，无论`T`是否是值类型，
`rc T`都可以被随意复制。

尽管内存由Deeplang动态管理，`rc T`依然是一种共享的权限。
当`T`内部有不由`rc`管理的数据时，
一个比较简单的`rc T`实现依然可能导致内存安全问题。
考虑一段使用引用计数管理的，有两个域`x`、`y`的结构体的数据。
如果一段程序通过一个（共享的）所有者保存了一个对`x`的借用，
而另一段程序通过另一个所有者修改了整段数据，
那么访问第一段程序里对`x`的借用就会产生内存安全问题。

为了解决这一安全问题，
Deeplang中，`rc T`除了维护引用计数，
还会维护对其内部的值的“借用数”（独立于“所有者数量”的引用计数），
在运行时动态地保证借用规则得到遵守。
当对一段`rc T`管理的数据进行写入时，
如果这段数据有借用，则会导致运行时错误。
同样地，在对一段`rc T`管理的数据进行借用（而不是通过复制增加所有者）时，
如果这次借用会违反借用规则，同样会导致运行时错误。

显然，维护这一额外的计数是否会导致`rc T`运行时开销增大，
并且动态维护借用规则会导致程序更容易出现运行时错误。
然而，为了保证内存安全，这是不可避免的。
为了缓解`rc T`的性能问题和运行时错误问题，下面是对`rc T`的使用的一些建议：

1. 尽量不要借用`rc T`内部的值。
即使借用，尽量不要存储它，而是马上使用完它后释放
1. 尽量不要在`rc T`内部混用唯一所有权和借用的数据，而是全部使用`rc T`。
这样一来就可以通过复制`rc T`来避免借用。

最后，引用计数无法处理循环引用。
如果有两个使用`rc`管理的值互相持有对对方的引用的话，
即使它们都已经无法被访问到，
也会因为互相的一份引用而无法被回收导致内存泄漏。
