# Deeplang内存管理实现文档

## 值类型
考虑对一个变量的直接使用`x`，
当`x`的类型是一个值类型时，
发生拷贝，`x`的所有权不受影响。
当`x`的类型不是值类型时，
发生所有权转移，`x`自身不再能被使用。

值类型包含以下类型：

- 内建的数字类型、字符类型
- 所有域都是值类型都是结构体
- 所有分支都不携带额外数据的ADT（类似C/C++中的enum）
- 只读借用`&T`
- 引用计数指针`rc T`

## 唯一所有权与借用
本节的内容以内存管理设施使用文档为基础。
也就是说，阅读时应当对内存管理系统中的使用权限和借用规则有所了解。
本节介绍的是借用系统在编译器内部的实现方式，
其中的很多内容不会出现在语言的语法中、用户也不需要知道。

### 位置
类型检查时，除了维护每个变量对应的类型，
还应当维护扔在作用域内、但已不能再被使用的变量。
更准确地说，应当维护“变量的一部分”。
例如，一个结构体`{ x : ..., y : ... }`中，
只有`x`能继续使用，`y`不能再被使用的情况也是允许的。
这种“管理使用权限的单元”称为“位置”，
路径可以是：

- 一个变量`x`（或是一个代表AST节点的id，如果需要支持对任意表达式取借用的话）
- 一个**位置变量** `L`，代表**一系列**未知的位置的**集合**
- 如果一个位置`l`指向一个结构体，`f`是该结构体的一个域，
那么`l.f`也是一个位置
- 如果一个位置`l`指向一个ADT，`B`是该ADT的一个分支，
那么`l.B`也是一个位置

可以看到，一个位置实际上是一条以变量或位置变量开头的路径。
因此，我们可以在位置上定义如下的操作：

- 比较操作，比较两个位置`l1`和`l2`。
可能的结果有四种：相等、`l1`是`l2`的一个前缀、`l2`是`l1`的一个前缀，
或`l1`、`l2`互不为前缀
- 取公共前缀的操作，找出`l1`和`l2`的最长公共前缀（可能为空）

如上面所说，位置是“管理使用权限的单元”。
因此，各种使用权限相关的信息都是通过位置记录的。
作为一条路径，位置同样是有类型的。
此外，每个位置还有对应的使用权限。
一个位置的使用权限是它的每个节点的使用权限中最弱的那个
（`T > &mut T > &T`）。

当一个位置具有某种临时借用的使用权限时，
它还应当有一个对应的所有者，表示将权限出借给它的那个位置。
这一所有者被定义为“最右边”的那个借用的所有者。
例如，考虑如下的位置：

    x        .f1        .f2        .f3         .f4
    ^^^      ^^^        ^^^        ^^^
    所有者   借用，     所有者     借用        所有者
             由l1所有              由l2所有

那么整个位置`x.f1.f2.f3`的所有者应当由`f3`决定，
所以它的所有者应当是`l2.f4`。

### 类型中的位置信息、位置变量上的约束、子类型
为了决定一个借用的所有者是谁，
编译器会在类型中放入额外的位置信息来记录所有者。
所以，借用类型`&T`和`&mut T`在编译器内部的形式是`&l T`和`&l mut T`，
其中`l`是一个位置，表示该借用的所有者。

然而，编译器并不是总能静态地找出一个确定的所有者。
例如，考虑下面的代码片段：

    let x = if (...) { &y } else { &z }

`x`的所有者既可能是`y`也可能是`z`。
具体是谁必须等到运行时、实际计算出了`if`的条件才能知道。
因此，单个的、具体的位置作为所有者是不够的。
这就是为什么位置中还包含了位置变量：它可以用来表达这种没有确定的所有者的情况。
接下来，还需要把位置变量和具体的位置联系起来。
为此，我们引入形如`l <= L`的**约束条件**，
其中`l`是一个位置、`L`是一个**位置变量**。
`l <= L`代表`l`应当包含在`L`代表的集合中。
现在上面的例子可以利用位置变量和约束条件来进行描述：

    let x = if (...) { &y } else { &z }
    // x : &L T where y <= L, z <= L

为了类型检查的实现，
约束条件中右侧的必须是单个位置变量。
但是`l <= L`这一有序关系可以拓展到任意两个位置之间。
这一拓展是通过两条规则来实现的：传递性，
以及“`l1 <= l2`能推出`l1.f <= l2.f`。

此外，类型中附带的也不是任意的位置，而是一个位置变量。
这会使得给位置赋予类型出现问题。
假设`p : &L Point`，那么`p.x`的类型应当是什么？
首先，由于`p.x`经过了`p`这个只读借用，它只有只读借用的权限。
因此，它的类型应当是`&? I32`。
然而，`?`处的、`p.x`的所有者应当是`L.x`：这不是一个位置变量。
为了解决这一问题，生成一个新的位置变量`L'`，并使`L.x <= L'`即可。

下一个必须考虑的问题是，位置如何参与到类型的相等判定中。
在调用一个函数，或是检查`if`的分支结果类型相同时，
必须判断两个类型是否相等/兼容。
由于位置间通过约束条件有天然的有序关系，
我们可以借助子类型来完成这一判断。
一个类型`S`是`T`的子类型，`S <= T`，
意味着`S`的每个值同时也是`T`中的值，就像集合上的子集关系。
在Deeplang内部，对于借用类型，有如下规则：

                              T <= T'    l <= l'
    T <= T'    l <= l'        T' <= T    l' <= l
    ------------------      ----------------------
      &l T <= &l' T'        &l mut T <= &l' mut T'

利用子类型关系，类型系统中剩下的规则就是标准的、带子类型的类型系统中的规则：

    f : S -> T             b : Bool    e1 : T1    e2 : T2
    a : S'    S' <= S                  T1 <= T    T2 <= T
    -----------------      -------------------------------
        f a : T             (if b { e1 } else { e2 }) : T

让我们回顾以下目前得到的东西：

- 通过借用类型中的位置、位置变量、以及它们上的约束条件，
我们得以表达每个借用的所有者是谁
- 通过子类型，所有者信息能够正确地沿着数据流传递

所以，我们接下来就可以利用得到的所有者信息来进行借用规则的维护。

### 借用规则的维护
在内存管理系统中，核心的借用规则是：

1. 借用只能沿着如下方向发生：

        一个所有者   -> 一个读写借用/多个只读借用
        一个读写借用 -> 一个读写借用/多个只读借用
        多个只读借用 -> 多个只读借用
1. 对一个**位置**的生命周期结束或被赋值时，
   它出借的所有权限必须被收回

在借用检查中，上述规则的维护是基于**收回权限**来实现的。
比如说，当对一个位置`l`取读写借用时，
如果对`l`已经有其他借用`x`存在了，
那么此时编译器不会拒绝这次借用，而是会**收回**`x`上的权限，
将它转而借给新的借用。
这之后，当再次**使用**`x`时，才会触发编译错误：
因为`x`已经失去了它的使用权限。
这么做的好处是，每个位置的实际生命周期变得非常灵活，
从而能够使得更多正确的程序被编译器接受。

于是，剩下的问题就是：应该收回哪些位置？
假设我们要收回一个位置`l`的使用权限，
但出于安全起见，所有**可能**是`l`的借用的位置都应该被回收，
所以所有类型为`&l' T`，其中`l <= l'`的位置都应该被回收。
此外，`l`中的每一部分，例如`l.x`、`l.y`上的权限也应当被回收。

为了回收了对一个位置`l`的**直接**借用，
还需要收回“借用的借用”，
因此，回收一个位置的权限是一个递归的过程。
但在一般的程序中，不会出现嵌套次数过多的借用，
所以这一过程的性能开销应当是可以接受的。

此外，编译器内部还应实现只回收特定的某种使用权限的操作。
例如，产生一个`l`的只读借用时，
只需要回收`l`的读写借用的权限，不需要回收其他只读借用的权限。

有了回收权限的操作后，借用规则的维护就十分直白了：

- 对`l`产生一个新借用时，首先需要收回`l`的权限。
例如，产生一个只读借用时应收回`l`的所有读写借用的权限，
产生一个读写借用时应收回`l`的所有借用的权限。
- 对`l`进行移动、赋值或`l`的生命周期结束时，
需要收回`l`的所有权限

### 具体语言构造的处理方式
在类型检查中，需要维护一系列关于位置变量的约束条件、
每个变量对应的类型，以及一个已经被收回权限的位置的列表。
一个位置的“存活状况”可能有四种：

1. 完整：即一个位置以及它的每一部分都没有被收回权限
1. 可写入：即对一个位置所在的内存的使用权限还在，
但它的某些部分的权限已经收回了，因而不能读取
1. 死亡：即一个位置是一个已经失去权限的位置的一部分。
对该位置已不能做任何操作

由于借用检查在对所有者赋值时支持strong updage，即改变类型的赋值，
而且类型检查过程会产生新的约束条件、回收更多位置的权限
类型检查的返回值除了类型外还有新的变量环境、约束条件和死亡位置列表。
一些语言构造在类型/借用检查时的大致处理方式如下：

- 对于字面量，包括数字、结构体和ADT创建，
直接返回一个具有所有者权限的类型

- 复制一个位置时，首先保证该位置是完整的，
接下来直接返回该值的类型

- 移动一个位置时，首先保证该位置是完整的，
接下来收回该位置上的所有权限，并返回该位置自身的类型

- 当对一个位置`l`进行借用时，首先保证该位置是完整的，
而且有足够的权限完成这次借用（例如对一个只读借用取读写借用是不合法的），
接下来收回必要的权限（取只读借用时，收回所有读写借用的权限。取读写借用时，收回全部权限），
并返回`l`的类型，但把权限替换成借出的权限，
其中位置的部分填一个新的位置变量`L`，并使`l <= L`

- 当对一个权限是**所有者**的位置`l`进行赋值时，
首先保证`l`是**可写入**的，接下来收回它的所有权限，
检查新的值的类型和`l`原来的类型**除了位置变量以外**是相同的，
最后把`l`的类型**替换为新值的类型**

- 当对一个权限是**读写借用**的位置进行赋值时，
首先保证`l`是**完整**的，接下来收回它的所有权限，
并检查新的值的类型与`l`原来的类型**是互为子类型的**

- 当检查函数调用时，
首先将函数的类型中的每个位置变量都替换为一个新的位置变量
（位置变量上的“泛型”是必要的，否则会导致极大量合法程序被拒绝），
接下来检查每个**实际参数**的类型都是对应**形式参数**类型的**子类型**，
并返回函数的结果类型

- 当检查模式匹配时，首先检查被匹配的表达式的类型。
接下来对每个分支分别进行检查。
首先，检查每个分支中的模式，得到被绑定的变量的类型。
每个模式/变量都会对应被匹配的表达式的某个位置，因此模式中也可能产生借用。
检查完模式的部分后，检查该分支对应的代码块，记录返回的结果，
并回收模式绑定的局部变量的所有权限（因为它们的生命周期结束了）
并保证该回收后分支的结果类型是完整的。
所有分支检查完后，合并各个分支的结果

- 检查一个循环时，需要得到循环任意次（包括零次）后的结果。
为此，需要找到一组兼容循环前状态、而且执行循环体后不变的变量类型/约束条件/死亡位置列表。
幸运的是，执行一段程序产生的约束条件只和各个变量的类型有关，和当前的其他约束条件无关。
同理，死亡位置的列表和已经死亡的位置无关。
所以，不需要反复检查循环体直到找到循环不变量
首先，用未循环的状态检查一遍循环体，
接下来，通过添加新的约束条件使得检查前后各个变量的类型相等。
如此得到的变量类型和约束条件就已经是循环不变量了。
接下来，用新的变量类型/约束条件再检查一次循环体，
即可得到正确的死亡位置列表，完成对循环的检查

- 检查一个函数时，首先给各个参数的类型中借用的部分赋予一个新的位置变量
（因为语言语法中没有位置相关的概念），
接下来检查函数体、收回所有参数的权限、并保证函数的返回值是完整的

- 检查一个全局函数，
或是一个通过`let`绑定到局部变量的闭包（如果语言支持闭包）时，
结果类型应当被被泛化成一个（位置变量上）参数多态的泛型类型


### 错误信息
内存管理方案中，语言的语法比起编译器内部的实现是极大简化的。
这一方面降低了语言的学习成本，但也可能导致编译错误难以理解。
因此，详细、易读、不涉及编译器内部细节的错误信息是**必要**的。
对于违反借用规则产生的错误，目前设计的错误信息格式如下：

    the location <l> cannot be used,
    because its access is already taken away,
    due to
    ( assignment to <bla>
    | <bla> going out of scope
    | <bla> being borrowed immutably/mutably )
    
    <l> may be a immutable/mutable borrow of <bla>
    because:
    (a list of program points,
     indicating the path/dataflow that
     makes <l> a borrow of <bla>)

其中，第一部分（某个位置`l`不再能被使用的理由）可以通过来借用检查过程中，
记录每个失去使用权限的位置失去权限的原因来实现。
第二部分则需要在每一条关于位置的约束条件上都记录一个源程序位置，
代表产生这一约束条件的程序片段。


### 一些额外的改进与拓展
其中，读写借用`&l mut T`由于即可读取又可写入，是不变（invariant）的，
而只读借用`&l T`则是协变（covariant）的。
这里，使`&l mut T`是不变的是比较标准的做法，但它会导致一些精度损失。
考虑如下的例子：

    let m = if (...) { &mut x } else { &mut y }
由于读写借用的不变性，`x`和`y`的类型必须是相等的
（互为子类型，上面子类型规则中`T <= T'`且`T' <= T`的部分）。
但这是一个不正确的结论，因为`x`和`y`的类型只需要“形状”相同即可，
它们内部从谁那里借了权限是互相没有关联的。
解决这个问题的办法同样是在子类型相关领域的一个经典做法：
在`&l mut T`中记录**两个**类型，一个代表读取，一个代表写入。
于是`&l mut T`将变成`&l mut (R, W)`。
如此一来，类型`R`是协变的、而`W`是逆变的，
从而就不会有不变性带来的精度问题。
当从读写借用中读取数据时，使用类型`R`；
反之，向读写借用写入数据时，使用类型`W`。
只要要求`W <= R`，就能保证类型正确性。



## 引用计数

### 借用计数
为了保证内存安全，引用计数必须额外维护一个“借用计数”，
以处理与所有权/借用机制的互动。
简单起见，借用计数不维护是哪一部分被借用了。
因此假如有一个`p : rc Point`的值，
同时对`p.x`和`p.y`取读写借用会产生运行时错误。

加入借用计数后，一段引用计数管理的数据的内存表示如下（使用C++语法）：

    struct Rc<T> {
        int ref_count;
        int borrow_count;
        T data
    };
其中`borrow_count`取最大值时表示有一个读写借用，
否则表示有`borrow_count`个只读借用。
`ref_count`和`borrow_count`可以被压缩一个word中，
具体的长度也可以调整。
对引用计数，主要有如下几个操作：

    void dup(Rc<T> *p) {
        p->ref_count += 1;
        return p;
    }
    
    void drop(Rc<T> *p) {
        if (p->ref_count == 1) {
           /* 借用系统会保证对p的“这一份”引用此时已经没有借用了
            * 而如果p是最后一份引用，此时借用计数必定为0 */
           /* 如果`p`中有其他`rc`指针，应当对这些指针也调用`drop` */
           delete p;
        }
        else
            p->ref_count -= 1;
    }
注意这里呈现的`drop`是简化过的，
借用计数相关的操作是：

    void borrow_imm(Rc<T> *p) {
        if (p->borrow_count == MUT_BORROW)
            abort();
        p->borrow_count += 1;
    }
    
    void drop_imm_borrow(Rc<T> *p) {
        p->borrow_count -= 1;
    }
    
    void borrow_mut(Rc<T> *p) {
        if (p->borrow_count != 0)
            abort();
        p->borrow_count = MUT_BORROW
    }
    
    void drop_mut_borrow(Rc<T> *p) {
        p->borrow_count = 0;
    }
其中`MUT_BORROW`是代表有读写借用存在的特殊常量，
可以取`borrow_count`范围内的最大值。
这些操作应当由编译器在生成代码时插入到程序中，具体来说：

- 在复制一个`rc T`前应当调用`dup`
- 在一个`rc T`的生命周期结束前应当调用`drop`
- 在对一个`rc T`进行赋值时应当保证`borrow_count`为0，
否则产生运行时错误
- 在对一个`rc T`进行只读借用前应当调用`borrow_imm`，
这个借用的权限被收回前应当调用`drop_imm_borrow`
- 同理，进行读写借用/收回读写借用的权限前应当调用`borrow_mut`/`drop_mut_borrow`

### Perceus优化
一个朴素的引用计数实现会有较大的性能开销，
在加入了借用计数的额外开销后更是如此。
为了减小这一开销，编译器内部使用[perceus](https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf)
中的技术来优化引用计数。

Perceus中的优化包含多个方面。
在编译器中准备实现的是：

- Perceus中提供了一个插入`dup/drop`的算法，
能够使内存最及时地被释放、减少不必要的引用计数开销。
对借用计数的操作也可以类似地生成

可能会实现的是：

- Perceus中提供了几种进一步优化引用计数的方法。
主要是把析构器/`drop`内联到生成的代码中后，
进行一些`dup/drop` fusion。
这一优化要方便地实现可能需要某种更扁平的IR，
以完成将`dup/drop`沿着控制流向下推的操作
（在生成的代码上由于控制流是通过非结构化的`goto`实现的很难完成这一操作）

下面简要介绍这两个优化。
更详细的内容可以参考[原论文](https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf)。
首先是Perceus的主算法：`dup/drop`的插入。
这一插入算法将会把一个不含`dup/drop`的表达式翻译成一个正确地插入了
`dup/drop`的新表达式。
在运行过程中，除了“有哪些变量”的上下文外，
perceus还会维护一个额外的上下文，
记录“**当前表达式可以不经复制使用哪些变量**”。
接下来，算法大致的运行过程如下：

- 遇到对一个变量`x`的复制时，如果`x`在“可以不经复制使用的变量”的列表中，
那么无需插入`dup`
- 否则，需要先插入`dup(x)`后才能使用`x`
- 无论如何，在使用完`x`后要插入`drop(x)`
（Preceus原论文中这一点是在他的语义内完成的，不包含在算法中）
- 遇到有多个子表达式的复合表达式，例如`a + b`时，
假设语言的求值顺序是先`a`后`b`，
假设`b`会使用到的变量是`xs`，
那么Perceus会允许`a`不经复制使用**不在**`xs`中的变量，
允许`b`不经复制使用`xs`中的变量
- 遇到控制流分叉的结构，如`if`/模式匹配时，
应当在每个分支前`drop`所有该分支不需要使用的变量

Perceus中提到的一种额外优化如下：

- 首先，将所有`drop`内联到代码中
- 沿着控制流将`dup`往下推，例如：

        dup(x);
        if (...) { b1 } else { b2 }
  会被转化为

        if (...) { dup(x); b1 }
        else     { dup(x); b2 }
- 相邻的`dup`和`drop`将会被消除，也就是说形如`dup(x); drop(x); ...`
的程序会被简化成`...`
