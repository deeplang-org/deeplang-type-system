<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ParseTree (deeplangType@26bb1931b3ad.DeeplangType.ParseTree)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">deeplangType@26bb1931b3ad</a> &#x00BB; <a href="../index.html">DeeplangType</a> &#x00BB; ParseTree</nav><h1>Module <code>DeeplangType.ParseTree</code></h1><nav class="toc"><ul><li><a href="#helper-definitions">Helper Definitions</a></li><li><a href="#types">Types</a></li><li><a href="#patterns">Patterns</a></li><li><a href="#expressions">Expressions</a></li><li><a href="#statements">Statements</a></li><li><a href="#top-level-expressions">Top Level Expressions</a></li></ul></nav></header><aside><p>This module defines the abstract syntax of deeplang.</p></aside><aside><p>The <em>DISCUSSION ONLY</em> labels below are constructs that need further discussion/clarification. Here are some of the most important ones:</p><ul><li>Should we make a expr-statement distinction (as in C/C++/Java), or use a completely expression based setting (as in Rust/OCaml)?</li><li><p>The syntax tree itself may not be very suitable to later phrases. For example, evaluation order is implicit, and it might be more desirable to use a ANF'ed IR. IMO there are three possible options for this problem:</p><ol><li>use the parse tree for everything. But may make later phrases harder.</li><li>define another IR, and translate the parse tree to it. But may take up more memory.</li><li>use another IR, and perform the translation in 2 at parsing time. Will make the parser more complex.</li></ol></li></ul></aside><section><header><h2 id="helper-definitions"><a href="#helper-definitions" class="anchor"></a>Helper Definitions</h2></header><dl><dt class="spec type" id="type-node_id"><a href="#type-node_id" class="anchor"></a><code><span class="keyword">type</span> node_id</code><code> = </code><table class="variant"><tr id="type-node_id.NodeId" class="anchored"><td class="def constructor"><a href="#type-node_id.NodeId" class="anchor"></a><code>| </code><code><span class="constructor">NodeId</span> <span class="keyword">of</span> int</code></td></tr></table></dt><dd><p><code>node_id</code> is a global, unique identifier for every node in a AST. <em>DISCUSSION WANTED</em>:</p><ul><li>which AST sorts need a <code>node_id</code>?</li><li>should different AST sorts have different <code>node_id</code> types?</li></ul></dd></dl><dl><dt class="spec type" id="type-symbol_id"><a href="#type-symbol_id" class="anchor"></a><code><span class="keyword">type</span> symbol_id</code><code> = </code><table class="variant"><tr id="type-symbol_id.SymbolId" class="anchored"><td class="def constructor"><a href="#type-symbol_id.SymbolId" class="anchor"></a><code>| </code><code><span class="constructor">SymbolId</span> <span class="keyword">of</span> int</code></td></tr></table></dt><dd><p><code>symbol_id</code> is a global, unique identifier for <em>declarations</em>. For every declared new name, there should be a unique <code>symbol_id</code> associated with it. <b>DISCUSSION WANTED</b>:</p><ul><li>should different kinds of declarations have different <code>symbol_id</code> types?</li></ul></dd></dl><dl><dt class="spec type" id="type-src_span"><a href="#type-src_span" class="anchor"></a><code><span class="keyword">type</span> src_span</code><code> = </code><code>{</code><table class="record"><tr id="type-src_span.file" class="anchored"><td class="def field"><a href="#type-src_span.file" class="anchor"></a><code>file : string;</code></td><td class="doc"><p>source file name. <code>&quot;&quot;</code> if none</p></td></tr><tr id="type-src_span.row_s" class="anchored"><td class="def field"><a href="#type-src_span.row_s" class="anchor"></a><code>row_s : int;</code></td><td class="doc"><p>row number of the start of the region</p></td></tr><tr id="type-src_span.col_s" class="anchored"><td class="def field"><a href="#type-src_span.col_s" class="anchor"></a><code>col_s : int;</code></td><td class="doc"><p>column number of the start of the region</p></td></tr><tr id="type-src_span.row_e" class="anchored"><td class="def field"><a href="#type-src_span.row_e" class="anchor"></a><code>row_e : int;</code></td><td class="doc"><p>row number of the end of the region</p></td></tr><tr id="type-src_span.col_e" class="anchored"><td class="def field"><a href="#type-src_span.col_e" class="anchor"></a><code>col_e : int;</code></td><td class="doc"><p>column number of the end of the region</p></td></tr></table><code>}</code></dt><dd><p><code>src_span</code> is a region in some source file. Used to report error messages</p></dd></dl><dl><dt class="spec type" id="type-variable"><a href="#type-variable" class="anchor"></a><code><span class="keyword">type</span> variable</code><code> = string</code></dt><dt class="spec type" id="type-struct_field"><a href="#type-struct_field" class="anchor"></a><code><span class="keyword">type</span> struct_field</code><code> = string</code></dt><dt class="spec type" id="type-adt_label"><a href="#type-adt_label" class="anchor"></a><code><span class="keyword">type</span> adt_label</code><code> = string</code></dt><dt class="spec type" id="type-method_name"><a href="#type-method_name" class="anchor"></a><code><span class="keyword">type</span> method_name</code><code> = string</code></dt></dl></section><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-int_typ_sign"><a href="#type-int_typ_sign" class="anchor"></a><code><span class="keyword">type</span> int_typ_sign</code><code> = </code><table class="variant"><tr id="type-int_typ_sign.Signed" class="anchored"><td class="def constructor"><a href="#type-int_typ_sign.Signed" class="anchor"></a><code>| </code><code><span class="constructor">Signed</span></code></td></tr><tr id="type-int_typ_sign.Unsigned" class="anchored"><td class="def constructor"><a href="#type-int_typ_sign.Unsigned" class="anchor"></a><code>| </code><code><span class="constructor">Unsigned</span></code></td></tr></table></dt><dt class="spec type" id="type-int_typ_size"><a href="#type-int_typ_size" class="anchor"></a><code><span class="keyword">type</span> int_typ_size</code><code> = </code><table class="variant"><tr id="type-int_typ_size.ISize_8" class="anchored"><td class="def constructor"><a href="#type-int_typ_size.ISize_8" class="anchor"></a><code>| </code><code><span class="constructor">ISize_8</span></code></td></tr><tr id="type-int_typ_size.ISize_16" class="anchored"><td class="def constructor"><a href="#type-int_typ_size.ISize_16" class="anchor"></a><code>| </code><code><span class="constructor">ISize_16</span></code></td></tr><tr id="type-int_typ_size.ISize_32" class="anchored"><td class="def constructor"><a href="#type-int_typ_size.ISize_32" class="anchor"></a><code>| </code><code><span class="constructor">ISize_32</span></code></td></tr><tr id="type-int_typ_size.ISize_64" class="anchored"><td class="def constructor"><a href="#type-int_typ_size.ISize_64" class="anchor"></a><code>| </code><code><span class="constructor">ISize_64</span></code></td></tr></table></dt><dt class="spec type" id="type-float_typ_size"><a href="#type-float_typ_size" class="anchor"></a><code><span class="keyword">type</span> float_typ_size</code><code> = </code><table class="variant"><tr id="type-float_typ_size.FSize_32" class="anchored"><td class="def constructor"><a href="#type-float_typ_size.FSize_32" class="anchor"></a><code>| </code><code><span class="constructor">FSize_32</span></code></td></tr><tr id="type-float_typ_size.FSize_64" class="anchored"><td class="def constructor"><a href="#type-float_typ_size.FSize_64" class="anchor"></a><code>| </code><code><span class="constructor">FSize_64</span></code></td></tr></table></dt><dt class="spec type" id="type-typ_name"><a href="#type-typ_name" class="anchor"></a><code><span class="keyword">type</span> typ_name</code><code> = string</code></dt><dt class="spec type" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span class="keyword">type</span> typ</code><code> = </code><code>{</code><table class="record"><tr id="type-typ.shape" class="anchored"><td class="def field"><a href="#type-typ.shape" class="anchor"></a><code>shape : <a href="index.html#type-typ_shape">typ_shape</a>;</code></td></tr><tr id="type-typ.span" class="anchored"><td class="def field"><a href="#type-typ.span" class="anchor"></a><code>span : <a href="index.html#type-src_span">src_span</a>;</code></td></tr></table><code>}</code></dt><dd><p>The abstract syntax of deeplang types. The name is <code>typ</code> to avoid conflict with OCaml's builtin keyword. <code>typ</code> only declares extra data stored with each node, the structure of deeplang types are defined in <code>typ_shape</code> <em>DISCUSSION WANTED</em>:</p><ul><li>should types have a unique id like <code>node_id</code> too?</li><li>should types be hash-consing'ed?</li></ul></dd></dl><dl><dt class="spec type" id="type-typ_shape"><a href="#type-typ_shape" class="anchor"></a><code><span class="keyword">and</span> typ_shape</code><code> = </code><table class="variant"><tr id="type-typ_shape.TyUnit" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyUnit" class="anchor"></a><code>| </code><code><span class="constructor">TyUnit</span></code></td></tr><tr id="type-typ_shape.TyBool" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyBool" class="anchor"></a><code>| </code><code><span class="constructor">TyBool</span></code></td></tr><tr id="type-typ_shape.TyInt" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyInt" class="anchor"></a><code>| </code><code><span class="constructor">TyInt</span> <span class="keyword">of</span> <a href="index.html#type-int_typ_sign">int_typ_sign</a> * <a href="index.html#type-int_typ_size">int_typ_size</a></code></td></tr><tr id="type-typ_shape.TyFloat" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyFloat" class="anchor"></a><code>| </code><code><span class="constructor">TyFloat</span> <span class="keyword">of</span> <a href="index.html#type-float_typ_size">float_typ_size</a></code></td></tr><tr id="type-typ_shape.TyChar" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyChar" class="anchor"></a><code>| </code><code><span class="constructor">TyChar</span></code></td></tr><tr id="type-typ_shape.TyThis" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyThis" class="anchor"></a><code>| </code><code><span class="constructor">TyThis</span></code></td></tr><tr id="type-typ_shape.TyArray" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyArray" class="anchor"></a><code>| </code><code><span class="constructor">TyArray</span> <span class="keyword">of</span> <a href="index.html#type-typ">typ</a> * int</code></td></tr><tr id="type-typ_shape.TyArrow" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyArrow" class="anchor"></a><code>| </code><code><span class="constructor">TyArrow</span> <span class="keyword">of</span> <a href="index.html#type-typ">typ</a> * <a href="index.html#type-typ">typ</a></code></td></tr><tr id="type-typ_shape.TyNamed" class="anchored"><td class="def constructor"><a href="#type-typ_shape.TyNamed" class="anchor"></a><code>| </code><code><span class="constructor">TyNamed</span> <span class="keyword">of</span> <a href="index.html#type-typ_name">typ_name</a></code></td></tr></table></dt><dd><p><code>typ_shape</code> declares the structure of deeplang types <em>DISCUSSION WANTED</em>:</p><ul><li>multi paramater arrow types?</li></ul></dd></dl></section><section><header><h2 id="patterns"><a href="#patterns" class="anchor"></a>Patterns</h2></header><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> pattern</code><code> = </code><code>{</code><table class="record"><tr id="type-pattern.shape" class="anchored"><td class="def field"><a href="#type-pattern.shape" class="anchor"></a><code>shape : <a href="index.html#type-pattern_shape">pattern_shape</a>;</code></td></tr><tr id="type-pattern.pat_id" class="anchored"><td class="def field"><a href="#type-pattern.pat_id" class="anchor"></a><code>pat_id : <a href="index.html#type-node_id">node_id</a>;</code></td></tr><tr id="type-pattern.span" class="anchored"><td class="def field"><a href="#type-pattern.span" class="anchor"></a><code>span : <a href="index.html#type-src_span">src_span</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-pattern_shape"><a href="#type-pattern_shape" class="anchor"></a><code><span class="keyword">and</span> pattern_shape</code><code> = </code><table class="variant"><tr id="type-pattern_shape.PatWildcard" class="anchored"><td class="def constructor"><a href="#type-pattern_shape.PatWildcard" class="anchor"></a><code>| </code><code><span class="constructor">PatWildcard</span></code></td></tr><tr id="type-pattern_shape.PatVar" class="anchored"><td class="def constructor"><a href="#type-pattern_shape.PatVar" class="anchor"></a><code>| </code><code><span class="constructor">PatVar</span> <span class="keyword">of</span> <a href="index.html#type-variable">variable</a></code></td></tr><tr id="type-pattern_shape.PatADT" class="anchored"><td class="def constructor"><a href="#type-pattern_shape.PatADT" class="anchor"></a><code>| </code><code><span class="constructor">PatADT</span> <span class="keyword">of</span> <a href="index.html#type-adt_label">adt_label</a> * <span><a href="index.html#type-pattern">pattern</a> list</span></code></td></tr><tr id="type-pattern_shape.PatStruct" class="anchored"><td class="def constructor"><a href="#type-pattern_shape.PatStruct" class="anchor"></a><code>| </code><code><span class="constructor">PatStruct</span> <span class="keyword">of</span> <span><span>(<a href="index.html#type-struct_field">struct_field</a> * <a href="index.html#type-pattern">pattern</a>)</span> list</span></code></td></tr></table></dt></dl></section><section><header><h2 id="expressions"><a href="#expressions" class="anchor"></a>Expressions</h2></header><dl><dt class="spec type" id="type-literal"><a href="#type-literal" class="anchor"></a><code><span class="keyword">type</span> literal</code><code> = </code><table class="variant"><tr id="type-literal.LitBool" class="anchored"><td class="def constructor"><a href="#type-literal.LitBool" class="anchor"></a><code>| </code><code><span class="constructor">LitBool</span> <span class="keyword">of</span> bool</code></td></tr><tr id="type-literal.LitInt" class="anchored"><td class="def constructor"><a href="#type-literal.LitInt" class="anchor"></a><code>| </code><code><span class="constructor">LitInt</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-literal.LitFloat" class="anchored"><td class="def constructor"><a href="#type-literal.LitFloat" class="anchor"></a><code>| </code><code><span class="constructor">LitFloat</span> <span class="keyword">of</span> float</code></td></tr><tr id="type-literal.LitString" class="anchored"><td class="def constructor"><a href="#type-literal.LitString" class="anchor"></a><code>| </code><code><span class="constructor">LitString</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dt class="spec type" id="type-binary_op"><a href="#type-binary_op" class="anchor"></a><code><span class="keyword">type</span> binary_op</code><code> = </code><table class="variant"><tr id="type-binary_op.BinOpLt" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLt" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLt</span></code></td></tr><tr id="type-binary_op.BinOpLeq" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLeq" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLeq</span></code></td></tr><tr id="type-binary_op.BinOpGt" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpGt" class="anchor"></a><code>| </code><code><span class="constructor">BinOpGt</span></code></td></tr><tr id="type-binary_op.BinOpGeq" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpGeq" class="anchor"></a><code>| </code><code><span class="constructor">BinOpGeq</span></code></td></tr><tr id="type-binary_op.BinOpEq" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpEq" class="anchor"></a><code>| </code><code><span class="constructor">BinOpEq</span></code></td></tr><tr id="type-binary_op.BinOpNeq" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpNeq" class="anchor"></a><code>| </code><code><span class="constructor">BinOpNeq</span></code></td></tr><tr id="type-binary_op.BinOpLOr" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLOr" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLOr</span></code></td></tr><tr id="type-binary_op.BinOpLAnd" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLAnd" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLAnd</span></code></td></tr><tr id="type-binary_op.BinOpLNot" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLNot" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLNot</span></code></td></tr><tr id="type-binary_op.BinOpLShift" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpLShift" class="anchor"></a><code>| </code><code><span class="constructor">BinOpLShift</span></code></td></tr><tr id="type-binary_op.BinOpRShift" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpRShift" class="anchor"></a><code>| </code><code><span class="constructor">BinOpRShift</span></code></td></tr><tr id="type-binary_op.BinOpAdd" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpAdd" class="anchor"></a><code>| </code><code><span class="constructor">BinOpAdd</span></code></td></tr><tr id="type-binary_op.BinOpSub" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpSub" class="anchor"></a><code>| </code><code><span class="constructor">BinOpSub</span></code></td></tr><tr id="type-binary_op.BinOpMul" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpMul" class="anchor"></a><code>| </code><code><span class="constructor">BinOpMul</span></code></td></tr><tr id="type-binary_op.BinOpDiv" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpDiv" class="anchor"></a><code>| </code><code><span class="constructor">BinOpDiv</span></code></td></tr><tr id="type-binary_op.BinOpMod" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpMod" class="anchor"></a><code>| </code><code><span class="constructor">BinOpMod</span></code></td></tr><tr id="type-binary_op.BinOpAssign" class="anchored"><td class="def constructor"><a href="#type-binary_op.BinOpAssign" class="anchor"></a><code>| </code><code><span class="constructor">BinOpAssign</span> <span class="keyword">of</span> <span><a href="index.html#type-binary_op">binary_op</a> option</span></code></td></tr></table></dt><dd><p>Some notes on <code>BinOpAssign</code>:</p><ul><li><code>BinOpAssign None</code> is normal assignment</li><li><code>BinOpAssign Add</code> is &quot;+=&quot;, <code>BinOpAssign Sub</code> is &quot;-=&quot;, etc.</li><li>Not all operators have corresponding assignment operators in the parser</li></ul></dd></dl><dl><dt class="spec type" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span class="keyword">type</span> expr</code><code> = </code><code>{</code><table class="record"><tr id="type-expr.shape" class="anchored"><td class="def field"><a href="#type-expr.shape" class="anchor"></a><code>shape : <a href="index.html#type-expr_shape">expr_shape</a>;</code></td></tr><tr id="type-expr.expr_id" class="anchored"><td class="def field"><a href="#type-expr.expr_id" class="anchor"></a><code>expr_id : <a href="index.html#type-node_id">node_id</a>;</code></td></tr><tr id="type-expr.span" class="anchored"><td class="def field"><a href="#type-expr.span" class="anchor"></a><code>span : <a href="index.html#type-src_span">src_span</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-expr_shape"><a href="#type-expr_shape" class="anchor"></a><code><span class="keyword">and</span> expr_shape</code><code> = </code><table class="variant"><tr id="type-expr_shape.ExpLit" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpLit" class="anchor"></a><code>| </code><code><span class="constructor">ExpLit</span> <span class="keyword">of</span> <a href="index.html#type-literal">literal</a></code></td></tr><tr id="type-expr_shape.ExpVar" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpVar" class="anchor"></a><code>| </code><code><span class="constructor">ExpVar</span> <span class="keyword">of</span> <a href="index.html#type-variable">variable</a></code></td></tr><tr id="type-expr_shape.ExpBinOp" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpBinOp" class="anchor"></a><code>| </code><code><span class="constructor">ExpBinOp</span> <span class="keyword">of</span> <a href="index.html#type-binary_op">binary_op</a> * <a href="index.html#type-expr">expr</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr_shape.ExpField" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpField" class="anchor"></a><code>| </code><code><span class="constructor">ExpField</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <span><a href="index.html#type-struct_field">struct_field</a> list</span></code></td></tr><tr id="type-expr_shape.ExpApp" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpApp" class="anchor"></a><code>| </code><code><span class="constructor">ExpApp</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr><tr id="type-expr_shape.ExpNew" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpNew" class="anchor"></a><code>| </code><code><span class="constructor">ExpNew</span> <span class="keyword">of</span> <a href="index.html#type-typ_name">typ_name</a> * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr><tr id="type-expr_shape.ExpMethod" class="anchored"><td class="def constructor"><a href="#type-expr_shape.ExpMethod" class="anchor"></a><code>| </code><code><span class="constructor">ExpMethod</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <a href="index.html#type-method_name">method_name</a> * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr></table></dt><dd><p><em>DISCUSSION WANTED</em>:</p><ul><li>Should we make a expr-statement distinction (as in C/C++/Java), or use a completely expression based setting (as in Rust)?</li><li>Should we preserve the &quot;evil&quot; ++/-- operators?</li></ul></dd></dl></section><section><header><h2 id="statements"><a href="#statements" class="anchor"></a>Statements</h2></header><dl><dt class="spec type" id="type-mutability"><a href="#type-mutability" class="anchor"></a><code><span class="keyword">type</span> mutability</code><code> = </code><table class="variant"><tr id="type-mutability.Imm" class="anchored"><td class="def constructor"><a href="#type-mutability.Imm" class="anchor"></a><code>| </code><code><span class="constructor">Imm</span></code></td></tr><tr id="type-mutability.Mut" class="anchored"><td class="def constructor"><a href="#type-mutability.Mut" class="anchor"></a><code>| </code><code><span class="constructor">Mut</span></code></td></tr></table></dt><dt class="spec type" id="type-declaration"><a href="#type-declaration" class="anchor"></a><code><span class="keyword">type</span> declaration</code><code> = </code><code>{</code><table class="record"><tr id="type-declaration.decl_name" class="anchored"><td class="def field"><a href="#type-declaration.decl_name" class="anchor"></a><code>decl_name : string;</code></td></tr><tr id="type-declaration.decl_id" class="anchored"><td class="def field"><a href="#type-declaration.decl_id" class="anchor"></a><code>decl_id : <a href="index.html#type-symbol_id">symbol_id</a>;</code></td></tr><tr id="type-declaration.decl_value" class="anchored"><td class="def field"><a href="#type-declaration.decl_value" class="anchor"></a><code>decl_value : <a href="index.html#type-expr">expr</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-stmt"><a href="#type-stmt" class="anchor"></a><code><span class="keyword">type</span> stmt</code><code> = </code><code>{</code><table class="record"><tr id="type-stmt.shape" class="anchored"><td class="def field"><a href="#type-stmt.shape" class="anchor"></a><code>shape : <a href="index.html#type-stmt_shape">stmt_shape</a>;</code></td></tr><tr id="type-stmt.stmt_id" class="anchored"><td class="def field"><a href="#type-stmt.stmt_id" class="anchor"></a><code>stmt_id : <a href="index.html#type-node_id">node_id</a>;</code></td></tr><tr id="type-stmt.span" class="anchored"><td class="def field"><a href="#type-stmt.span" class="anchor"></a><code>span : <a href="index.html#type-src_span">src_span</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-stmt_shape"><a href="#type-stmt_shape" class="anchor"></a><code><span class="keyword">and</span> stmt_shape</code><code> = </code><table class="variant"><tr id="type-stmt_shape.StmtExpr" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtExpr" class="anchor"></a><code>| </code><code><span class="constructor">StmtExpr</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-stmt_shape.StmtDecl" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtDecl" class="anchor"></a><code>| </code><code><span class="constructor">StmtDecl</span> <span class="keyword">of</span> <a href="index.html#type-declaration">declaration</a></code></td></tr><tr id="type-stmt_shape.StmtIf" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtIf" class="anchor"></a><code>| </code><code><span class="constructor">StmtIf</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <a href="index.html#type-stmt">stmt</a> * <a href="index.html#type-stmt">stmt</a></code></td></tr><tr id="type-stmt_shape.StmtFor" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtFor" class="anchor"></a><code>| </code><code><span class="constructor">StmtFor</span> <span class="keyword">of</span> <a href="index.html#type-stmt">stmt</a> * <a href="index.html#type-expr">expr</a> * <a href="index.html#type-stmt">stmt</a> * <a href="index.html#type-stmt">stmt</a></code></td></tr><tr id="type-stmt_shape.StmtWhile" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtWhile" class="anchor"></a><code>| </code><code><span class="constructor">StmtWhile</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <a href="index.html#type-stmt">stmt</a></code></td></tr><tr id="type-stmt_shape.StmtMatch" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtMatch" class="anchor"></a><code>| </code><code><span class="constructor">StmtMatch</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a> * <span><span>(<a href="index.html#type-pattern">pattern</a> * <a href="index.html#type-stmt">stmt</a>)</span> list</span></code></td></tr><tr id="type-stmt_shape.StmtReturn" class="anchored"><td class="def constructor"><a href="#type-stmt_shape.StmtReturn" class="anchor"></a><code>| </code><code><span class="constructor">StmtReturn</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a></code></td></tr></table></dt><dd><p><em>DISCUSSION WANTED</em>:</p><ul><li>expr/statement distinction, or expr only (see above)</li><li>for loop: range/iterator based loops?</li></ul></dd></dl><dl><dt class="spec type" id="type-for_loop_init"><a href="#type-for_loop_init" class="anchor"></a><code><span class="keyword">and</span> for_loop_init</code><code> = </code><table class="variant"><tr id="type-for_loop_init.ForInitDecl" class="anchored"><td class="def constructor"><a href="#type-for_loop_init.ForInitDecl" class="anchor"></a><code>| </code><code><span class="constructor">ForInitDecl</span> <span class="keyword">of</span> <a href="index.html#type-declaration">declaration</a></code></td></tr><tr id="type-for_loop_init.ForInitExpr" class="anchored"><td class="def constructor"><a href="#type-for_loop_init.ForInitExpr" class="anchor"></a><code>| </code><code><span class="constructor">ForInitExpr</span> <span class="keyword">of</span> <a href="index.html#type-expr">expr</a></code></td></tr></table></dt></dl></section><section><header><h2 id="top-level-expressions"><a href="#top-level-expressions" class="anchor"></a>Top Level Expressions</h2></header><dl><dt class="spec type" id="type-has_impl"><a href="#type-has_impl" class="anchor"></a><code><span class="keyword">type</span> has_impl</code><code> = </code><table class="variant"><tr id="type-has_impl.HasImpl" class="anchored"><td class="def constructor"><a href="#type-has_impl.HasImpl" class="anchor"></a><code>| </code><code><span class="constructor">HasImpl</span></code></td></tr></table></dt><dt class="spec type" id="type-no_impl"><a href="#type-no_impl" class="anchor"></a><code><span class="keyword">type</span> no_impl</code><code> = </code><table class="variant"><tr id="type-no_impl.NoImpl" class="anchored"><td class="def constructor"><a href="#type-no_impl.NoImpl" class="anchor"></a><code>| </code><code><span class="constructor">NoImpl</span></code></td></tr></table></dt><dd><p><code>has_impl</code> and <code>no_impl</code> are used only as index of <code>optional_impl</code> below. Their values have no meaning and are never used.</p></dd></dl><dl><dt class="spec type" id="type-optional_impl"><a href="#type-optional_impl" class="anchor"></a><code><span class="keyword">type</span> <span>(_, _) optional_impl</span></code><code> = </code><table class="variant"><tr id="type-optional_impl.NoImpl" class="anchored"><td class="def constructor"><a href="#type-optional_impl.NoImpl" class="anchor"></a><code>| </code><code><span class="constructor">NoImpl</span> : <span><span>(<span class="type-var">'a</span>,Â <a href="index.html#type-no_impl">no_impl</a>)</span> <a href="index.html#type-optional_impl">optional_impl</a></span></code></td></tr><tr id="type-optional_impl.HasImpl" class="anchored"><td class="def constructor"><a href="#type-optional_impl.HasImpl" class="anchor"></a><code>| </code><code><span class="constructor">HasImpl</span> : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>,Â <a href="index.html#type-has_impl">has_impl</a>)</span> <a href="index.html#type-optional_impl">optional_impl</a></span></code></td></tr></table></dt><dd><p><code>('a, 'kind) optional_impl</code> is similar to <code>'a option</code>, but whether there is a value of type <code>'a</code> is reflected by the type index <code>'kind</code>:</p><ul><li>When <code>'kind</code> is <code>no_impl</code>, there is no value.</li><li>When <code>'kind</code> is <code>has_impl</code>, there is a value of type <code>'a</code>.</li></ul><p>This type is used below to simplify definition of <code>top_expr</code>.</p></dd></dl><dl><dt class="spec type" id="type-top_expr"><a href="#type-top_expr" class="anchor"></a><code><span class="keyword">type</span> top_expr</code><code> = </code><code>{</code><table class="record"><tr id="type-top_expr.shape" class="anchored"><td class="def field"><a href="#type-top_expr.shape" class="anchor"></a><code>shape : <a href="index.html#type-top_expr_shape">top_expr_shape</a>;</code></td></tr><tr id="type-top_expr.span" class="anchored"><td class="def field"><a href="#type-top_expr.span" class="anchor"></a><code>span : <a href="index.html#type-src_span">src_span</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-top_expr_shape"><a href="#type-top_expr_shape" class="anchor"></a><code><span class="keyword">and</span> top_expr_shape</code><code> = </code><table class="variant"><tr id="type-top_expr_shape.DefStruct" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.DefStruct" class="anchor"></a><code>| </code><code><span class="constructor">DefStruct</span> <span class="keyword">of</span> <a href="index.html#type-struct_def">struct_def</a></code></td></tr><tr id="type-top_expr_shape.DefADT" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.DefADT" class="anchor"></a><code>| </code><code><span class="constructor">DefADT</span> <span class="keyword">of</span> <a href="index.html#type-adt_def">adt_def</a></code></td></tr><tr id="type-top_expr_shape.DeclInterface" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.DeclInterface" class="anchor"></a><code>| </code><code><span class="constructor">DeclInterface</span> <span class="keyword">of</span> <span><a href="index.html#type-no_impl">no_impl</a> <a href="index.html#type-interface_def">interface_def</a></span></code></td></tr><tr id="type-top_expr_shape.ImplInterface" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.ImplInterface" class="anchor"></a><code>| </code><code><span class="constructor">ImplInterface</span> <span class="keyword">of</span> <span><a href="index.html#type-has_impl">has_impl</a> <a href="index.html#type-interface_def">interface_def</a></span></code></td></tr><tr id="type-top_expr_shape.DefFunction" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.DefFunction" class="anchor"></a><code>| </code><code><span class="constructor">DefFunction</span> <span class="keyword">of</span> <span><a href="index.html#type-has_impl">has_impl</a> <a href="index.html#type-function_def">function_def</a></span></code></td></tr><tr id="type-top_expr_shape.DefVariable" class="anchored"><td class="def constructor"><a href="#type-top_expr_shape.DefVariable" class="anchor"></a><code>| </code><code><span class="constructor">DefVariable</span> <span class="keyword">of</span> <a href="index.html#type-variable_def">variable_def</a></code></td></tr></table></dt><dd><p>The type of top level expressions.</p></dd></dl><dl><dt class="spec type" id="type-struct_def"><a href="#type-struct_def" class="anchor"></a><code><span class="keyword">and</span> struct_def</code><code> = </code><code>{</code><table class="record"><tr id="type-struct_def.struct_name" class="anchored"><td class="def field"><a href="#type-struct_def.struct_name" class="anchor"></a><code>struct_name : <a href="index.html#type-typ_name">typ_name</a>;</code></td></tr><tr id="type-struct_def.struct_fields" class="anchored"><td class="def field"><a href="#type-struct_def.struct_fields" class="anchor"></a><code>struct_fields : <span><a href="index.html#type-struct_def_field">struct_def_field</a> list</span>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-struct_def_field"><a href="#type-struct_def_field" class="anchor"></a><code><span class="keyword">and</span> struct_def_field</code><code> = </code><table class="variant"><tr id="type-struct_def_field.StructField" class="anchored"><td class="def constructor"><a href="#type-struct_def_field.StructField" class="anchor"></a><code>| </code><code><span class="constructor">StructField</span> <span class="keyword">of</span> <a href="index.html#type-struct_field">struct_field</a> * <a href="index.html#type-typ">typ</a></code></td></tr><tr id="type-struct_def_field.StructDelegate" class="anchored"><td class="def constructor"><a href="#type-struct_def_field.StructDelegate" class="anchor"></a><code>| </code><code><span class="constructor">StructDelegate</span> <span class="keyword">of</span> <a href="index.html#type-struct_field">struct_field</a> * <a href="index.html#type-typ">typ</a></code></td></tr></table></dt><dt class="spec type" id="type-adt_def"><a href="#type-adt_def" class="anchor"></a><code><span class="keyword">and</span> adt_def</code><code> = </code><code>{</code><table class="record"><tr id="type-adt_def.adt_name" class="anchored"><td class="def field"><a href="#type-adt_def.adt_name" class="anchor"></a><code>adt_name : <a href="index.html#type-typ_name">typ_name</a>;</code></td></tr><tr id="type-adt_def.adt_branches" class="anchored"><td class="def field"><a href="#type-adt_def.adt_branches" class="anchor"></a><code>adt_branches : <span><span>(<a href="index.html#type-adt_label">adt_label</a> * <a href="index.html#type-typ">typ</a>)</span> list</span>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-interface_def"><a href="#type-interface_def" class="anchor"></a><code><span class="keyword">and</span> <span>'kind interface_def</span></code><code> = </code><code>{</code><table class="record"><tr id="type-interface_def.interface_name" class="anchored"><td class="def field"><a href="#type-interface_def.interface_name" class="anchor"></a><code>interface_name : <a href="index.html#type-typ_name">typ_name</a>;</code></td></tr><tr id="type-interface_def.interface_methods" class="anchored"><td class="def field"><a href="#type-interface_def.interface_methods" class="anchor"></a><code>interface_methods : <span><span><span class="type-var">'kind</span> <a href="index.html#type-function_def">function_def</a></span> list</span>;</code></td></tr></table><code>}</code></dt><dd><p><code>declaration interface_def</code> is an interface declaration. <code>implementation interface_def</code> is an interface implementation. <em>DISCUSSION WANTED</em>:</p><ul><li>Should we support generic interface, interface dependency, etc.?</li></ul></dd></dl><dl><dt class="spec type" id="type-function_def"><a href="#type-function_def" class="anchor"></a><code><span class="keyword">and</span> <span>'kind function_def</span></code><code> = </code><code>{</code><table class="record"><tr id="type-function_def.func_name" class="anchored"><td class="def field"><a href="#type-function_def.func_name" class="anchor"></a><code>func_name : <a href="index.html#type-variable">variable</a>;</code></td></tr><tr id="type-function_def.func_args" class="anchored"><td class="def field"><a href="#type-function_def.func_args" class="anchor"></a><code>func_args : <span><span>(<a href="index.html#type-variable">variable</a> * <a href="index.html#type-symbol_id">symbol_id</a> * <a href="index.html#type-typ">typ</a>)</span> list</span>;</code></td></tr><tr id="type-function_def.func_ret" class="anchored"><td class="def field"><a href="#type-function_def.func_ret" class="anchor"></a><code>func_ret : <a href="index.html#type-typ">typ</a>;</code></td></tr><tr id="type-function_def.func_body" class="anchored"><td class="def field"><a href="#type-function_def.func_body" class="anchor"></a><code>func_body : <span><span>(<a href="index.html#type-expr">expr</a>,Â <span class="type-var">'kind</span>)</span> <a href="index.html#type-optional_impl">optional_impl</a></span>;</code></td></tr></table><code>}</code></dt><dd><p><code>declaration function_def</code> is an function declaration. <code>implementation function_def</code> is an function implementation. <code>func_body</code> will only be present for function implementations</p></dd></dl><dl><dt class="spec type" id="type-variable_def"><a href="#type-variable_def" class="anchor"></a><code><span class="keyword">and</span> variable_def</code><code> = </code><code>{</code><table class="record"><tr id="type-variable_def.var_name" class="anchored"><td class="def field"><a href="#type-variable_def.var_name" class="anchor"></a><code>var_name : <a href="index.html#type-variable">variable</a>;</code></td></tr><tr id="type-variable_def.var_id" class="anchored"><td class="def field"><a href="#type-variable_def.var_id" class="anchor"></a><code>var_id : <a href="index.html#type-symbol_id">symbol_id</a>;</code></td></tr><tr id="type-variable_def.var_value" class="anchored"><td class="def field"><a href="#type-variable_def.var_value" class="anchor"></a><code>var_value : <a href="index.html#type-expr">expr</a>;</code></td></tr></table><code>}</code></dt></dl></section></div></body></html>