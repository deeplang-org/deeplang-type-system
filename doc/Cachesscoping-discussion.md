# 命名空间设计的讨论

目前，在Deeplang中有如下几种“名字”，
根据命名规范可以分为大写开头者：

- 类型名字
- ADT的label名字
- interface名字

这三者的命名空间设计比较简单：
把它们放在不同命名空间即可。
对于类型名字和interface名字，禁止有重名。
对于ADT的label的名字，是否允许重名有两种做法：

- 禁止重名，OCaml是这么做的（选择）
- 允许重名，Rust是这么做的。
但为了消除歧义，创建ADT时必须在label名字前面加上`<类型名字>::`。


小写开头的名字则有如下几种：

- 变量
- 结构体的field
- 普通函数
- 方法

变量的情况最复杂，留待最后讨论。
首先是关于剩下的三者处于什么命名空间中的问题。
结构体的field和普通函数显然应当处于不同命名空间中。
普通函数和方法也应当处于不同命名空间中，理由是：

- 1.A：普通函数所在的命名空间应当禁止重名
- 1.B：不同的类型在匿名`impl`中实现相同名字的方法是一个很常见的场景。
所以方法的命名空间不应该禁止重名。

所以二者对命名空间的需求是矛盾的。
并且，将二者放在不同命名空间中也是十分易于实现的，
因为普通函数调用和方法调用的语法是不同的（`f(a)` v.s. `a.f()`）。

第二个问题是**不同**类型的field、方法是否允许重名。
不同的类型应当允许同名field，
否则委托无法实现。
接下来，为了消除歧义，创建结构体时应当提供类型名字（参考Rust）。

对于不同类型的方法，又分为匿名`impl`中的方法和interface中声明的方法两类。
其中，不同类型的匿名`impl`中的方法应当允许重名，
这是基本无需讨论的。
其次，每一个类型`T`都不应该给同一个方法名字提供多份实现，
否则就需要某种重载机制来消除歧义，这是我们不希望看到的。
这意味着如果一个类型实现了interface `I`中的一个方法`f`，
那么它在匿名`impl`中就不能再实现另一个`f`了，
同时它也不能实现其他包含一个叫`f`的方法的interface了。
在此基础上，有如下几种不同做法：

- 3.A：允许任意的重名，但同一个类型依然不能多次实现同一个方法名字。
- 3.B：不同interface中声明的方法不允许重名，但匿名`impl`不受任何重名限制。同一个类型里面，不能有两个同名实现。
- 3.C：匿名`impl`和不同interface中都不允许重名，（不考虑）
只有不同类型的匿名`impl`之间允许重名。

下一个问题是**同一个**类型的field和方法之间是否允许重名的问题。
考虑到语法的相似性（`a.f` v.s. `a.f(...)`），
最好不允许。实现上，在`impl`中进行重名检查即可。

最后，考虑变量的重名规则。
为了方便讨论，考虑如下的例子：
    // 作用域S1
    let <声明D1>;
    let <声明D2>;

    for (let <声明D3>; ...) {
        // 作用域S2
    }
    for (let <声明D4>; ...) {
        // 作用域S3
    }
其中，作用域`S2`和`S3`互相平行，并且都嵌套在`S1`中。
`D3`和`D4`（也就是平行、互不嵌套的作用域）之间的重名是必须要允许的。
所以剩下的需要选择的就是`<D1>`和`<D2>`、`<D1>`、`<D2>`和`<D3>`、`<D4>`之间是否允许重名。
有如下几种方案：

- 4.A：禁止除平行作用域外的所有重名，这是C89的行为。（不建议）
由于`<D1>`和`<D3>`间的重名被禁止了，会使程序的命名更受限。
- 4.B：允许所有的重名，包括`<D1>`和`<D2>`之间。新的声明会覆盖旧的声明，（不建议）
这是OCaml的行为。
- 4.C：禁止`<D1>`和`<D2>`的重名，允许`<D1>`和`<D3>`的重名。（暂时选择）
这是C99/C++的行为。
- 4.D：语法上区分“会覆盖”和“不会覆盖”两种不同的声明，
前者将旧声明覆盖掉，后者不能和旧声明同名。
一个可能的语法是`let`（不覆盖）和`let!`（覆盖）。

我个人的观点如下：
- 4.A的实现和理解都很简单，但对程序命名的限制可能过强了。
- 4.B在实现上同样很简单（因为重名的处理为了支持平行作用域的重名本来就是必须做的）。
在理解上，函数式语言中会重度利用4.B来实现一些局部状态的逻辑，
但在非函数式语言中，可能会导致一些理解困难，以及一些打错名字导致的错误更难发现。
- 4.C是大部分程序员比较熟悉的做法，因此在理解上很简单也很清晰。
然而，“作用域”这一概念在实现中其实是人工造出来的，所以会导致实现更加麻烦。
- 4.D允许对重名的最自由、最精确的控制。
不需要命名时使用`let`，意外重名时编译器会报错。
需要重名时显式地使用`let!`即可。
我没有印象在其他语言中见过这种做法，
不过我认为这一语义足够简单，应该不会导致理解困难。
需要引入新的语法同样是缺点之一，
不过`let/let!`这种语法的噪音还是非常小的。
