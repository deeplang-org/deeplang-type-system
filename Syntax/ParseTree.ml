

(** This module defines the abstract syntax of deeplang.
    The syntax tree will be used for all subsequent compiler passes,
    until code generation. *)


(** {1 Helper Definitions} *)
open SyntaxError

type variable     = string [@@deriving show]
type func_name    = string [@@deriving show]
type struct_field = string [@@deriving show]
type adt_label    = string [@@deriving show]
type typ_name     = string [@@deriving show]
type method_name  = string [@@deriving show]
type intf_name    = string [@@deriving show]


(** a globally unique id for {e variables} *)
type symbol = Symbol of int [@@unboxed] [@@deriving show]


(** [NodeId] contains types for unique ids
    for various kinds of AST nodes.
    Can be used to attach extra data to AST nodes,
    via an external table. *)
module NodeId = struct
    type pattern = PatId  of int [@@unboxed] [@@deriving show]
    type expr    = ExprId of int [@@unboxed] [@@deriving show]
    type stmt    = StmtId of int [@@unboxed] [@@deriving show]
    type impl    = ImplId of int [@@unboxed] [@@deriving show]
end



(** {1 Types } *)

type int_typ_sign = Signed | Unsigned [@@deriving show]
type int_typ_size = ISize_8 | ISize_16 | ISize_32 | ISize_64 [@@deriving show]

type float_typ_size = FSize_32 | FSize_64 [@@deriving show]

let string_of_int_type sign size = 
    (match sign with
    | Signed   -> "I"
    | Unsigned -> "U") ^
    (match size with
    | ISize_8  -> "8"
    | ISize_16 -> "16"
    | ISize_32 -> "32"
    | ISize_64 -> "64");
    [@@deriving show]

(** For types internally generated by the compiler,
    [span] should be [None]. *)
type typ =
    { shape : typ_shape
    ; span  : src_span }
    [@@deriving show]

(** [typ_shape] declares the structure of deeplang types *)
and typ_shape =
    | TyVar   of string
    | TyUnit
    | TyBool
    | TyInt   of int_typ_sign * int_typ_size
    | TyFloat of float_typ_size
    | TyChar
    | TyThis
    | TyArray of typ * int
    | TyTuple of typ list
    (* user-defined types with optional type arguments *)
    | TyNamed of typ_name * typ list
    [@@deriving show]

(** {1 Patterns} *)

type literal =
    | LitUnit
    | LitBool   of bool
    | LitInt    of int
    | LitFloat  of float
    (** 16-bit *)
    | LitChar   of int
    | LitString of string
    [@@deriving show]

type mutability = Imm | Mut [@@deriving show]

type var_pattern =
    { vpat_mut  : mutability
    ; vpat_typ  : typ option
    ; vpat_name : variable
    ; vpat_symb : symbol }
    [@@deriving show]

type pattern =
    { shape  : pattern_shape
    ; pat_id : NodeId.pattern
    ; span   : src_span }
    [@@deriving show]

and pattern_shape =
    | PatWildcard
    | PatLit    of literal
    | PatVar    of var_pattern
    | PatAs     of pattern * var_pattern
    | PatADT    of adt_label * pattern list
    | PatStruct of typ_name * (struct_field * pattern) list
    | PatTuple  of pattern list
    [@@deriving show]

(** {1 Expressions} *)

type unary_op =
    | UnOpNeg | UnOpNot [@@deriving show]

type compare_op = 
    | BinOpLt | BinOpLeq | BinOpGt | BinOpGeq
    | BinOpEq | BinOpNeq [@@deriving show]
(** note : BinOpLNot --modify--> BinOpLXor 
 *  optional : | BinOpBOr | BinOpBAnd | BinOpBXor
 *    B = bit, |   '|'    |    '&'    |    '^'
 *  it might be useful for IoT development
 *)
type calculate_op =
    | BinOpLOr | BinOpLAnd | BinOpLXor
    | BinOpBOr | BinOpBAnd | BinOpBXor
    | BinOpLShift | BinOpRShift
    | BinOpAdd | BinOpSub | BinOpMul | BinOpDiv | BinOpMod
(** Some notes on [BinOpAssign]:
    - [BinOpAssign None] is normal assignment
    - [BinOpAssign Add] is "+=", [BinOpAssign Sub] is "-=", etc.
    - Not all operators have corresponding assignment operators
    in the parser. This is just a simplification of AST definition *)
    [@@deriving show]
type binary_op =
    | BinOpCompare   of compare_op
    | BinOpCalculate of calculate_op
    [@@deriving show]

type expr =
    { shape   : expr_shape
    ; expr_id : NodeId.expr
    ; span    : src_span }
    [@@deriving show]

and expr_shape =
    | ExpLit    of literal
    | ExpVar    of variable
    | ExpUnOp   of unary_op * expr
    | ExpBinOp  of binary_op * expr * expr
    | ExpTuple  of expr list
    | ExpADT    of adt_label * expr list
    | ExpStruct of typ_name * (struct_field * expr) list
    | ExpField  of expr * struct_field
    | ExpThis
    | ExpApp    of func_name * expr list
    | ExpMethod of expr * method_name * expr list
    | ExpIf     of expr * expr * expr
    | ExpMatch  of expr * (pattern * expr) list
    [@@deriving show]

(** {1 Statements} *)

type stmt =
    { shape   : stmt_shape
    ; stmt_id : NodeId.stmt
    ; span    : src_span }
    [@@deriving show]

and stmt_shape =
    | StmtSeq    of stmt list
    | StmtExpr   of expr
    | StmtDecl   of pattern * expr
    | StmtAssign of calculate_op option * expr * expr (* expr1 op?= expr2, where expr1 = ExpVar ONLY *)
    | StmtIf     of expr * stmt * stmt option
    | StmtFor    of pattern * expr * stmt
    | StmtWhile  of expr * stmt
    | StmtMatch  of expr * (pattern * stmt) list
    | StmtReturn of expr
    | StmtBreak
    | StmtContinue
    [@@deriving show]

(** {1 Top Level Clauses} *)

type global_variable_def =
    { gvar_name  : variable
    ; gvar_typ   : typ option
    ; gvar_id    : symbol
    ; gvar_value : expr }
    [@@deriving show]

type func_arg =
    { farg_name : variable
    ; farg_symb : symbol
    ; farg_typ  : typ }
    [@@deriving show]

type func_decl =
    { func_decl_name : func_name
    ; func_decl_args : func_arg list
    ; func_decl_rety : typ }
    [@@deriving show]

type func_impl = func_decl * stmt [@@deriving show]

type struct_def_field_attr =
    | Struct_Field
    | Struct_Delegate 
    [@@deriving show]

type struct_def_field = struct_field * typ * struct_def_field_attr
    [@@deriving show]

type struct_def =
    { struct_name   : typ_name
    ; struct_fields : struct_def_field list }
    [@@deriving show]

type adt_def =
    { adt_name     : typ_name
    ; adt_branches : (adt_label * typ list) list }
    [@@deriving show]

type interface_decl =
    { intf_decl_name    : intf_name
    ; intf_decl_methods : func_decl list }
    [@@deriving show]

type methods_impl =
    { impl_intf : intf_name option
    ; impl_typ  : typ_name (* just type name *)
    ; impl_id   : NodeId.impl (* no need? *)
    ; impl_methods : func_impl list }
    [@@deriving show]

type top_clause =
    { shape : top_clause_shape
    ; span  : src_span }
    [@@deriving show]

and top_clause_shape =
    | StructDef     of struct_def
    | ADTDef        of adt_def
    | InterfaceDecl of interface_decl
    | MethodsImpl   of methods_impl
    | FunctionDef   of func_impl
    | GlobalVarDef  of global_variable_def
    [@@deriving show]
