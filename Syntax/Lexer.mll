(* This ocamllex file was machine-generated by the BNF converter *)

(* preamble *)
{
open ParseTree
open Parser

let keyword_table = Hashtbl.of_seq @@ List.to_seq
    [ ("true"     , TOK_TRUE     )
    ; ("false"    , TOK_FALSE    )
    ; ("this"     , TOK_THIS     )
    ; ("as"       , TOK_AS       )
    ; ("if"       , TOK_IF       )
    ; ("else"     , TOK_ELSE     )
    ; ("while"    , TOK_WHILE    )
    ; ("for"      , TOK_FOR      )
    ; ("break"    , TOK_BREAK    )
    ; ("continue" , TOK_CONTINUE )
    ; ("let"      , TOK_LET      )
    ; ("mut"      , TOK_MUT      )
    ; ("in"       , TOK_IN       )
    ; ("match"    , TOK_MATCH    )
    ; ("fun"      , TOK_FUN      )
    ; ("return"   , TOK_RETURN   )
    ; ("interface", TOK_INTERFACE)
    ; ("impl"     , TOK_IMPL     )
    ; ("extends"  , TOK_EXTENDS  )
    ; ("type"     , TOK_TYPE     )
    ; ("Bool"     , TOK_TyBool   )
    ; ("Char"     , TOK_TyChar   )
    ; ("This"     , TOK_TyThis   )
    ; ("I8"       , TOK_TyInt(Signed  , ISize_8 ))
    ; ("U8"       , TOK_TyInt(Unsigned, ISize_8 ))
    ; ("I16"      , TOK_TyInt(Signed  , ISize_16))
    ; ("U16"      , TOK_TyInt(Unsigned, ISize_16))
    ; ("I32"      , TOK_TyInt(Signed  , ISize_32))
    ; ("U32"      , TOK_TyInt(Unsigned, ISize_32))
    ; ("I64"      , TOK_TyInt(Signed  , ISize_64))
    ; ("U64"      , TOK_TyInt(Unsigned, ISize_64))
    ; ("F32"      , TOK_TyFloat FSize_32)
    ; ("F64"      , TOK_TyFloat FSize_64) ]

let symbol_table = Hashtbl.of_seq @@ List.to_seq
    [ ("=>" , TOK_EQGT    )
    ; ("->" , TOK_MINUSGT )
    ; ("-"  , TOK_MINUS   )
    ; ("!"  , TOK_BANG    )
    ; ("<=" , TOK_LTEQ    )
    ; ("<"  , TOK_LT      )
    ; (">=" , TOK_GTEQ    )
    ; (">"  , TOK_GT      )
    ; ("==" , TOK_EQEQ    )
    ; ("!=" , TOK_BANGEQ  )
    ; ("||" , TOK_LOR     )
    ; ("&&" , TOK_LAND    )
    ; ("^^" , TOK_LXOR    )
    ; ("|"  , TOK_BOR     )
    ; ("&"  , TOK_BAND    )
    ; ("^"  , TOK_BXOR    )
    ; ("<<" , TOK_LSHIFT  )
    ; (">>" , TOK_RSHIFT  )
    ; ("+"  , TOK_ADD     )
    ; ("*"  , TOK_MUL     )
    ; ("/"  , TOK_DIV     )
    ; ("%"  , TOK_MOD     )
    ; ("|=" , TOK_BOREQ   )
    ; ("&=" , TOK_BANDEQ  )
    ; ("^=" , TOK_BXOREQ  )
    ; ("<<=", TOK_LSHIFTEQ)
    ; (">>=", TOK_RSHIFTEQ)
    ; ("+=" , TOK_ADDEQ   )
    ; ("-=" , TOK_MINUSEQ )
    ; ("*=" , TOK_MULEQ   )
    ; ("/=" , TOK_DIVEQ   )
    ; ("%=" , TOK_MODEQ   )
    ; ("="  , TOK_EQ      ) ]

let unescapeInitTail (s:string) : string =
  let rec unesc s = match s with
      '\\'::c::cs when List.mem c ['\"'; '\\'; '\''] -> c :: unesc cs
    | '\\'::'n'::cs  -> '\n' :: unesc cs
    | '\\'::'t'::cs  -> '\t' :: unesc cs
    | '\\'::'r'::cs  -> '\r' :: unesc cs
    | '\"'::[]    -> []
    | c::cs      -> c :: unesc cs
    | _         -> []
  (* explode/implode from caml FAQ *)
  in let explode (s : string) : char list =
      let rec exp i l =
        if i < 0 then l else exp (i - 1) (s.[i] :: l) in
      exp (String.length s - 1) []
  in let implode (l : char list) : string =
      let res = Buffer.create (List.length l) in
      List.iter (Buffer.add_char res) l;
      Buffer.contents res
  in implode (unesc (List.tl (explode s)))
}

(* BNFC character classes *)
let dex_digit  = ['0'-'9']
let lower      = ['a'-'z']
let upper      = ['A'-'Z']
let ident_char = dex_digit | lower | upper | ['_' '\'']
let operator   = ['<' '>' '=' '|' '&' '^' '+' '-' '*' '/' '%' '!']
let blank      = [' ' '\t' '\r']
let newline    = ['\n']

(* lexing rules *)
rule token = parse
    | eof     { TOK_EOF }
    | "//"    { comment_line  lexbuf }
    | "/*"    { comment_block lexbuf }
    | blank+  { token lexbuf }
    | newline { Lexing.new_line lexbuf; token lexbuf }
    | dex_digit+
        { TOK_Integer (int_of_string @@ Lexing.lexeme lexbuf) }
    | (dex_digit+)'.'(dex_digit+)
        { TOK_Double (float_of_string @@ Lexing.lexeme lexbuf) }
    | '\"' (([^ '\"' '\\' '\n']) | ('\\' ('\"' | '\\' | '\'' | 'n' | 't' | 'r')))* '\"'
        { TOK_String (unescapeInitTail (Lexing.lexeme lexbuf)) }
    | '\'' [^ '\'' '\\'] '\''
        { TOK_Char(Char.code (Lexing.lexeme lexbuf).[1]) }
    | "'\\n'"  { TOK_Char(Char.code '\n') }
    | "'\\t'"  { TOK_Char(Char.code '\t') }
    | "'\\r'"  { TOK_Char(Char.code '\r') }
    | "'\\\\'" { TOK_Char(Char.code '\\') }
    | "'\\''"  { TOK_Char(Char.code '\'') }
    | ('_'*)(lower)(ident_char*)
        { let ident = Lexing.lexeme lexbuf in
          match Hashtbl.find keyword_table ident with
          | token               -> token
          | exception Not_found -> TOK_LowerIdent ident }
    | ('_'*)(upper)(ident_char*)
        { let ident = Lexing.lexeme lexbuf in
          match Hashtbl.find keyword_table ident with
          | token               -> token
          | exception Not_found -> TOK_UpperIdent ident }
    | operator+
         { let op = Lexing.lexeme lexbuf in
           match Hashtbl.find symbol_table op with
           | token               -> token
           | exception Not_found ->
                raise @@ SyntaxError.Error(
                    { span_start = Lexing.lexeme_start_p lexbuf
                    ; span_end   = Lexing.lexeme_end_p lexbuf },
                    (* BadToken(Lexing.lexeme lexbuf) *)
                    Basic(
                        { unexpected = Some (Token (Lexing.lexeme lexbuf))
                        ; expecting  = [Label "operator"]
                        ; message    = None }
                    )
                ) }
    | '('  { TOK_LPAREN     }
    | ')'  { TOK_RPAREN     }
    | '['  { TOK_LBRACK     }
    | ']'  { TOK_RBRACK     }
    | '{'  { TOK_LBRACE     }
    | '}'  { TOK_RBRACE     }
    | ':'  { TOK_COLON      }
    | ','  { TOK_COMMA      }
    | '.'  { TOK_DOT        }
    | '_'  { TOK_UNDERSCORE }
    | ';'  { TOK_SEMICOLON  }
    | ['\000' - '\127'] 
    | ['\192' - '\223']['\128' - '\191'] 
    | ['\224' - '\239']['\128' - '\191']['\128' - '\191'] 
    | ['\240' - '\247']['\128' - '\191']['\128' - '\191']['\128' - '\191']
        { raise @@ SyntaxError.Error(
            { span_start = Lexing.lexeme_start_p lexbuf
            ; span_end   = Lexing.lexeme_end_p lexbuf },
            Unexpected("character '" ^ Lexing.lexeme lexbuf ^ "'")
        ) }
    | _
        { raise @@ SyntaxError.Error(
            { span_start = Lexing.lexeme_start_p lexbuf
            ; span_end   = Lexing.lexeme_end_p lexbuf },
            (* Unexpected("character '" ^ Lexing.lexeme lexbuf ^ "'") *)
            Basic(
                { unexpected = Some (Token (Lexing.lexeme lexbuf))
                ; expecting  = []
                ; message    = Some "Invalid UTF-8 character!" }
            )
        ) }

and comment_line = parse
    | newline { Lexing.new_line lexbuf; token lexbuf }
    | _       { comment_line lexbuf }

and comment_block = parse
    | "*/"    { token lexbuf }
    | newline { Lexing.new_line lexbuf; comment_block lexbuf }
    | _       { comment_block lexbuf }
